#!/usr/bin/env python3
"""
AUTO START BOT - Versi√≥n optimizada con mejoras ML
"""

import sys
import asyncio
import os
import json
from datetime import datetime, timedelta, timezone
from typing import Dict, Any
import random
from pathlib import Path
import time
import numpy as np
from collections import defaultdict
import requests
import warnings
import argparse
import hashlib
from enum import Enum
import yaml
warnings.filterwarnings('ignore')

# ============================================================================
# BOOT LOGGING DEDUPLICATION SYSTEM
# ============================================================================
_printed_flags = set()

def boot_log_once(key: str, msg: str):
    """Print a boot message only once to avoid duplicate logging"""
    if key not in _printed_flags:
        try:
            print(msg)
        except UnicodeEncodeError:
            # Fallback for Windows console encoding issues
            print(msg.encode('utf-8', errors='replace').decode('utf-8', errors='replace'))
        _printed_flags.add(key)

# ============================================================================
# GLOBAL CONFIGURATION FLAGS
# ============================================================================
VERBOSE_MARKET_CONTEXT = False  # Set to True to see detailed ETF/Dominance/Correlation logs
VERBOSE_SCORING = False  # Set to True to see detailed Advanced Score Breakdown
MODEL_RUNTIME_ID = None  # Will be set after model loads: "model_name|hash"

class BypassReason(Enum):
    """Enum for structured logging of bypass reasons"""
    THRESHOLD = "threshold"
    HOUR_PENALTY = "hour_penalty"
    STALE_DATA_SOFT = "stale_data_soft"
    STALE_DATA_HARD_LIMIT = "stale_data_hard_limit"
    ML_UNAVAILABLE = "ml_unavailable"
    SIMULATION_GUARD = "simulation_guard"
    ENHANCED_ML_ERROR = "enhanced_ml_error"
    BASIC_ML_ERROR = "basic_ml_error"

def get_utc_now():
    """Get current UTC time as the source of truth for all time calculations"""
    return datetime.now(timezone.utc)

# Add src to path
sys.path.append('src')

# Load environment variables
from dotenv import load_dotenv
load_dotenv('config/production.env')

# Import risk management modules
try:
    from risk.sizing import compute_position_size, min_notional_required
    from risk.exposure import will_breach_caps, symbol_cluster
    from risk.atr_risk import check_mae_hardcut, check_time_exit, get_atr
    from signals.macro_gates import apply_session_adjustments, allow_setup
    from policy.bandits import bandit
    from utils.logger import log_event
    RISK_MANAGEMENT_AVAILABLE = True
    boot_log_once("risk_mgmt", "‚úÖ Risk Management modules imported (all 11 modules)")
except ImportError as e:
    RISK_MANAGEMENT_AVAILABLE = False
    boot_log_once("risk_mgmt_err", f"‚ö†Ô∏è  Risk Management not available: {e}")

# Import symbol scoring system
SYMBOL_SCORING_AVAILABLE = False
try:
    from signals.symbol_scoring import select_symbols_deterministic, compute_symbol_score
    from signals.symbol_memory import SymbolMemory
    SYMBOL_SCORING_AVAILABLE = True
    boot_log_once("symbol_scoring", "‚úÖ Symbol Scoring System imported (deterministic selection)")
except ImportError as e:
    SYMBOL_SCORING_AVAILABLE = False
    boot_log_once("symbol_scoring_err", f"‚ö†Ô∏è  Symbol Scoring System not available: {e}")

# Import risk management V2 modules
RISK_MANAGEMENT_V2_AVAILABLE = False
try:
    from risk.pre_trade_hook_v2 import pre_trade_check_v2, execute_with_batching, log_pre_trade_result
    from risk.post_trade_monitor_v2 import monitor_position_v2, update_bandit_on_close, log_exit_decision
    from execution.microstructure import OrderbookSnapshot
    from execution.batching import flush_all as flush_batched_orders
    from signals.macro_gates import regime_params, threshold_by_session, should_block_mean_reversion, calculate_trend_score
    RISK_MANAGEMENT_V2_AVAILABLE = True
    boot_log_once("risk_mgmt_v2", "‚úÖ Risk Management V2 modules imported (enhanced features)")
except ImportError as e:
    RISK_MANAGEMENT_V2_AVAILABLE = False
    boot_log_once("risk_mgmt_v2_err", f"‚ö†Ô∏è  Risk Management V2 not available: {e}")
    boot_log_once("risk_mgmt_v2_fallback", "   Continuing with V1 risk management...")

# Import database and ML components
try:
    from simple_trade_database import SimpleTradeDatabase
    from daily_protection_system import DailyProtectionSystem
    boot_log_once("database", "‚úÖ Base de datos simplificada importada correctamente")
    TradeDatabase = SimpleTradeDatabase

    # ML Integration
    try:
        from src.ml.adaptive_engine import AdaptiveLearningEngine, AdaptiveConfig
        from src.ml.model_ensemble import ModelConfig
        ML_AVAILABLE = True
        boot_log_once("ml_engine", "‚úÖ ML Engine importado correctamente")
    except ImportError as e:
        ML_AVAILABLE = False
        boot_log_once("ml_engine_err", f"‚ö†Ô∏è  ML Engine no disponible: {e}")
        boot_log_once("ml_engine_fallback", "   Continuando con an√°lisis tradicional")
    
    # Analytics Engine Integration
    try:
        from advanced_analytics_engine import AdvancedAnalyticsEngine
        ANALYTICS_ENABLED = True
        boot_log_once("analytics", "‚úÖ Analytics Engine importado correctamente")
    except ImportError as e:
        ANALYTICS_ENABLED = False
        boot_log_once("analytics_err", f"‚ö†Ô∏è  Analytics Engine no disponible: {e}")
        boot_log_once("analytics_fallback", "   Continuando sin analytics avanzado")
        
except ImportError as e:
    boot_log_once("database_err", f"‚ö†Ô∏è  Error importando Database: {e}")
    boot_log_once("database_fallback", "Continuando sin integraci√≥n ML...")
    TradeDatabase = None
    DailyProtectionSystem = None
    ANALYTICS_ENABLED = False

# Import ML predictor
# Global model info - single source of truth
GLOBAL_MODEL_INFO = {
    'model_name': 'lightgbm_fase2',
    'model_version': 'v2.0_fase2',
    'model_file': 'ml_models/production/lightgbm_model_fase2.pkl',
    'model_hash': 'unknown',
    'model_loaded_at': 'unknown',
    'features_count': 'unknown',
    'ml_loaded': False
}

try:
    from simple_ml_predictor import get_ml_prediction, get_ml_info, set_position_tracker
    
    # Get model info to display version - UPDATE GLOBAL INFO
    try:
        ml_info = get_ml_info()
        # Update global model info with actual values
        GLOBAL_MODEL_INFO.update({
            'model_name': ml_info.get('model_name', 'lightgbm_fase2'),
            'model_version': ml_info.get('version', 'v2.0_fase2'),
            'model_hash': ml_info.get('model_hash', 'unknown'),
            'model_loaded_at': ml_info.get('model_loaded_at', 'unknown'),
            'features_count': ml_info.get('features_count', 'unknown'),
            'ml_loaded': ml_info.get('ml_loaded', False)
        })
        
        model_hash_short = GLOBAL_MODEL_INFO['model_hash'][:8] if GLOBAL_MODEL_INFO['model_hash'] != 'unknown' else 'unknown'
        
        # Create MODEL_RUNTIME_ID as single source of truth (module level, no need for global)
        MODEL_RUNTIME_ID = f"{GLOBAL_MODEL_INFO['model_name']}|{model_hash_short}"
        
        boot_log_once("ml_predictor", f"‚úÖ ML Predictor importado correctamente")
        boot_log_once("ml_predictor_info", 
            f"   Model: {GLOBAL_MODEL_INFO['model_name']} | "
            f"Version: {GLOBAL_MODEL_INFO['model_version']} | "
            f"Hash: {model_hash_short}")
        boot_log_once("ml_runtime_id", f"   Runtime ID: {MODEL_RUNTIME_ID}")
        
        # Print adapter info once
        boot_log_once("ml_adapter", "   ‚ÑπÔ∏è  Adaptador activo: legacy_features=16 ‚Üí model_input=50 (FASE 2 compatible)")
    except Exception as e:
        boot_log_once("ml_predictor", "‚úÖ ML Predictor importado correctamente")
        boot_log_once("ml_predictor_warn", f"   ‚ö†Ô∏è  Could not load model info: {e}")
    
    ML_PREDICTOR_AVAILABLE = True
except ImportError as e:
    boot_log_once("ml_predictor_err", f"‚ö†Ô∏è  Error importando ML Predictor: {e}")
    boot_log_once("ml_predictor_fallback", "Continuando con ML simulado...")
    ML_PREDICTOR_AVAILABLE = False

# Enhanced ML Integration
try:
    from offline_enhanced_ml import get_offline_enhanced_prediction, get_offline_analysis_breakdown
    ENHANCED_ML_AVAILABLE = True
    boot_log_once("enhanced_ml", "‚úÖ Enhanced ML offline importado")
except ImportError:
    ENHANCED_ML_AVAILABLE = False

# Shadow Mode Integration (FASE 2 Model)
try:
    from src.ml.shadow_mode_integration import ShadowModeIntegration
    SHADOW_MODE_AVAILABLE = True
    boot_log_once("shadow_mode", "‚úÖ Shadow Mode (FASE 2) importado")
except ImportError:
    SHADOW_MODE_AVAILABLE = False
    boot_log_once("shadow_mode_err", "‚ö†Ô∏è  Shadow Mode no disponible")

# Enhanced Policy Bundle v2.0 Integration
try:
    from engine.bot_integration import EnhancedPolicyIntegration
    ENHANCED_POLICY_AVAILABLE = True
    boot_log_once("enhanced_policy", "‚úÖ Enhanced Policy Bundle v2.0 importado")
except ImportError as e:
    ENHANCED_POLICY_AVAILABLE = False
    boot_log_once("enhanced_policy_err", f"‚ö†Ô∏è  Enhanced Policy Bundle no disponible: {e}")



# Enhanced ML Storage
try:
    from enhanced_ml_storage import EnhancedMLStorage
    ENHANCED_STORAGE_AVAILABLE = True
    boot_log_once("enhanced_storage", "‚úÖ Enhanced ML Storage importado")
except ImportError:
    ENHANCED_STORAGE_AVAILABLE = False
    boot_log_once("enhanced_storage_err", "‚ö†Ô∏è  Enhanced ML Storage no disponible")
# Enhanced Error Handler
try:
    from enhanced_error_handler import integrate_enhanced_error_handling
    ENHANCED_ERROR_HANDLER_AVAILABLE = True
    boot_log_once("enhanced_error", "‚úÖ Enhanced Error Handler importado")
except ImportError:
    ENHANCED_ERROR_HANDLER_AVAILABLE = False

try:
    import ccxt
    boot_log_once("ccxt", "‚úÖ CCXT importado correctamente")
except ImportError:
    print("‚ùå ERROR: CCXT no est√° instalado")
    print("Ejecuta: pip install ccxt")
    sys.exit(1)


# ============================================================================
# HELPER FUNCTIONS - Decision Flow Fixes
# ============================================================================

def _normalize_series(series):
    """
    Normalizar series a formato consistente para c√°lculos.
    Maneja DataFrame, Series, lista, array, None.
    
    Returns:
        (pd.Series, length) o (None, 0) si inv√°lido
    """
    import numpy as np
    import pandas as pd
    
    if series is None:
        return None, 0
    
    # DataFrame ‚Üí extraer columna close
    if isinstance(series, pd.DataFrame):
        if series.empty:
            return None, 0
        if 'close' in series.columns:
            s = series['close'].astype(float).dropna()
        else:
            # Usar primera columna num√©rica
            num_cols = [c for c in series.columns if np.issubdtype(series[c].dtype, np.number)]
            if num_cols:
                s = series[num_cols[0]].astype(float).dropna()
            else:
                s = series.iloc[:, 0].astype(float).dropna()
        return s, len(s)
    
    # Series ‚Üí usar directo
    if isinstance(series, pd.Series):
        s = series.dropna().astype(float)
        return s, len(s)
    
    # Lista/tuple/array ‚Üí convertir a Series
    if isinstance(series, (list, tuple, np.ndarray)):
        try:
            arr = np.array(series, dtype=float)
            s = pd.Series(arr).dropna()
            return s, len(s)
        except (ValueError, TypeError):
            return None, 0
    
    # Cualquier otro tipo ‚Üí None
    return None, 0


def is_stable_pair(symbol):
    """
    Verificar si un par es stablecoin vs stablecoin.
    No tiene sentido tradear estos pares.
    """
    STABLES = {"USDC", "USDT", "TUSD", "USDP", "BUSD", "DAI", "USDD"}
    
    try:
        base, quote = symbol.split("/")
        return base in STABLES and quote in STABLES
    except (ValueError, AttributeError):
        return False


class PortfolioHelper:
    """Helper class for exposure tracking"""
    
    def __init__(self, bot):
        self.bot = bot
    
    def equity(self):
        """Get current equity"""
        return self.bot.balance_usdt
    
    def cluster_exposure(self, cluster):
        """Calculate current exposure to a cluster as fraction of equity"""
        if not RISK_MANAGEMENT_AVAILABLE:
            return 0
        
        total = 0
        for sym, pos in self.bot.positions.items():
            if symbol_cluster(sym) == cluster:
                total += pos.get('trade_amount', 0)
        
        equity = self.equity()
        return total / equity if equity > 0 else 0
    
    def symbol_exposure(self, symbol):
        """Calculate current exposure to a symbol as fraction of equity"""
        if symbol in self.bot.positions:
            notional = self.bot.positions[symbol].get('trade_amount', 0)
            equity = self.equity()
            return notional / equity if equity > 0 else 0
        return 0


class AutoStartBinanceTrader:
    """Trader optimizado con mejoras ML implementadas"""
    
    def _load_yaml_config(self, path: str) -> dict:
        """Load YAML configuration file"""
        try:
            if os.path.exists(path):
                with open(path, 'r', encoding='utf-8') as f:
                    return yaml.safe_load(f) or {}
        except Exception as e:
            print(f"‚ö†Ô∏è  Error loading {path}: {e}")
        return {}
    
    def __init__(self):
        # Load optimized configuration
        self.config = self.load_optimized_config()
        
        # Load safe mode configuration if exists
        self.safe_mode_config = self.load_safe_mode_config()
        self.safe_mode = self.safe_mode_config is not None
        
        # Get initial balance for header display
        self.initial_balance_usdt = 0.0
        
        # ‚úÖ PATCH v1.3: Safe Mode auto-unlock tracking
        self.safe_mode_unlock_tracker = {
            'confidence_history': [],  # Last N confidence readings
            'window_size': 3,  # Number of consecutive checks needed
            'unlock_threshold': 0.65,  # Average confidence threshold
            'last_check': None
        }
        
        # Initialize database for ML training
        self.trade_db = None
        if TradeDatabase:
            try:
                self.trade_db = TradeDatabase()
                print("‚úÖ Base de datos inicializada para ML")
            except Exception as e:
                print(f"‚ö†Ô∏è  Error inicializando base de datos: {e}")
                self.trade_db = None
        
        # Initialize Analytics Engine
        self.analytics_engine = None
        self.analytics_counter = 0
        self.analytics_interval = 100  # Ejecutar analytics cada 100 trades
        if ANALYTICS_ENABLED:
            try:
                self.analytics_engine = AdvancedAnalyticsEngine()
                print("‚úÖ Analytics Engine inicializado")
            except Exception as e:
                print(f"‚ö†Ô∏è  Error inicializando Analytics Engine: {e}")
                self.analytics_engine = None
        
        # FASE 2: Runtime adjustments from analytics
        self.trading_paused = False
        self.position_multiplier = 1.0
        self.runtime_config_path = 'runtime_config.json'
        
        # FASE 3: EventBus for real-time communication
        self.event_bus = None
        self.event_listeners_started = False
        try:
            from src.core.event_bus import EventBus
            self.event_bus = EventBus(backend="memory")
            print("‚úÖ EventBus inicializado para comunicaci√≥n en tiempo real")
        except Exception as e:
            print(f"‚ö†Ô∏è  Error inicializando EventBus: {e}")
            self.event_bus = None
        
        # API credentials
        self.api_key = os.getenv('BINANCE_API_KEY')
        self.api_secret = os.getenv('BINANCE_API_SECRET')
        self.testnet = os.getenv('BINANCE_TESTNET', 'false').lower() == 'true'
        
        if not self.api_key or not self.api_secret:
            print("‚ö†Ô∏è  CONTINUANDO EN MODO SIMULACI√ìN...")
            self.simulation_mode = True
        else:
            self.simulation_mode = False
        
        # Load optimized trading parameters
        trading_config = self.config.get('trading', {})
        self.take_profit_percent = trading_config.get('take_profit_percent', 0.020) * 100
        # Stop-loss m√≠nimo efectivo - OPTIMIZADO POR ANALYTICS ENGINE
        # Incrementado de 2.0% a 1.5% m√≠nimo para mejor gesti√≥n de riesgo
        base_sl = trading_config.get('stop_loss_percent', 0.015) * 100  # M√≠nimo 1.5%
        self.stop_loss_percent = max(base_sl, 1.5)  # 1.5% m√≠nimo m√°s estricto
        # Remove hardcoded min_confidence - will use compute_effective_threshold()
        self.base_min_confidence = trading_config.get('min_confidence', 0.420)  # Base from config - AJUSTADO Nov 12
        # OPTIMIZADO POR ANALYTICS ENGINE: Reducir de 0.15 a 0.08 para reducir drawdown del 22.5% al <8%
        self.max_position_percent = min(trading_config.get('max_position_percent', 0.15), 0.08)
        self.analysis_frequency = trading_config.get('analysis_frequency_seconds', 90)
        
        # Trading symbols - Will be updated daily by market analysis
        self.default_symbols = trading_config.get('symbols', [
            'BTC/USDT', 'ETH/USDT', 'BNB/USDT', 'ADA/USDT', 'SOL/USDT',
            'XRP/USDT', 'DOGE/USDT', 'MATIC/USDT', 'DOT/USDT', 'AVAX/USDT'
        ])
        self.symbols = self.default_symbols.copy()  # Will be updated by daily analysis
        
        # Daily analysis settings
        self.daily_analysis_enabled = trading_config.get('daily_analysis_enabled', True)
        self.max_daily_symbols = trading_config.get('max_daily_symbols', 12)
        self.min_volume_usdt = trading_config.get('min_volume_usdt', 1000000)  # 1M USDT volume
        self.last_daily_analysis = None
        
        # Advanced analysis settings
        self.use_sentiment_analysis = trading_config.get('use_sentiment_analysis', True)
        self.use_fundamental_analysis = trading_config.get('use_fundamental_analysis', True)
        self.use_advanced_technical = trading_config.get('use_advanced_technical', True)
        
        # Cache for external API calls
        self.sentiment_cache = {}
        self.fundamental_cache = {}
        self.cache_duration = 3600  # 1 hour cache
        
        # Symbol-specific configurations
        symbol_config = self.config.get('symbol_specific', {})
        self.high_volatility_symbols = symbol_config.get('high_volatility_symbols', ['DOGE', 'PEPE', 'TRUMP'])
        
        # Centralized ML Engine initialization - use global predictor
        try:
            from simple_ml_predictor import ml_predictor as global_ml
            self.ml_engine = global_ml
            self.ml_enabled = True
            print("‚úÖ ML Engine centralizado inicializado correctamente")
        except ImportError as e:
            print(f"‚ö†Ô∏è  Error importando ML predictor global: {e}")
            self.ml_engine = None

        # ========================================
        # FASE 2: ML Runtime with Calibration
        # ========================================
        print("\n" + "="*60)
        print("üéØ FASE 2 - CALIBRACI√ìN Y CONFIANZA")
        print("="*60)
        
        try:
            from ml.runtime_loader import load_ml_runtime
            from gates.staleness import StalenessGate, LatencyMetrics
            from policy.thresholds import ThresholdManager
            from risk.health import DriftGuard, HealthMonitor
            from bootstrap.startup_card import print_startup_status
            
            # Load configurations
            staleness_config = self._load_yaml_config('config/staleness.yaml')
            health_config = self._load_yaml_config('config/health.yaml')
            
            # Load ML runtime with calibration
            self.fase2_predictor, self.fase2_runtime_id = load_ml_runtime()
            print(f"‚úÖ ML Runtime loaded: {self.fase2_runtime_id}")
            
            # Initialize staleness gate with config
            self.staleness_gate = StalenessGate(
                ttl_ms=3000,  # Base TTL
                latency_p99_ms=2500,  # Current P99 latency
                config=staleness_config
            )
            self.latency_metrics = LatencyMetrics(window_size=100)
            print(f"‚úÖ Staleness gate: TTL={self.staleness_gate.ttl_ms}ms, soft_ttl={self.staleness_gate.soft_ttl_minutes}min")
            
            # Initialize threshold manager
            self.threshold_mgr = ThresholdManager(self.config)
            print("‚úÖ Threshold manager initialized")
            
            # Initialize health monitoring with config
            drift_cfg = health_config.get('drift_guard', {}) if health_config else {}
            self.drift_guard = DriftGuard(
                drop_trigger=drift_cfg.get('trigger_drop', 0.12),
                cool_minutes=drift_cfg.get('cool_minutes', 60)
            )
            self.health_monitor = HealthMonitor()
            print("‚úÖ Health monitoring initialized")
            
            # Print startup card
            if self.fase2_predictor:
                print_startup_status(
                    runtime_id=self.fase2_runtime_id,
                    model_hash=self.fase2_predictor._compute_hash(self.fase2_predictor.model),
                    features_count=50,
                    scaler_hash=self.fase2_predictor.scaler_hash,
                    calibrator_hash=self.fase2_predictor.calibrator_hash,
                    ttl_ms=self.staleness_gate.ttl_ms,
                    base_threshold=0.78,
                    compact=True  # Use compact format
                )
            
            self.fase2_enabled = True
            print("="*60)
            
        except Exception as e:
            print(f"‚ö†Ô∏è  FASE 2 initialization error: {e}")
            print("   Continuing with standard ML...")
            self.fase2_enabled = False
            self.fase2_predictor = None
            self.staleness_gate = None
            self.threshold_mgr = None
            self.drift_guard = None
            self.health_monitor = None

        
        # Shadow Mode Integration (FASE 2 Model)
        # GO LIVE: Shadow Mode completado - Activando nuevo modelo en producci√≥n
        self.shadow_mode = None
        self.ml_enabled = True
        print("üöÄ GO LIVE: Nuevo modelo ML FASE 2 activado en producci√≥n")
        print(f"   üìÖ Deployment date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"   üè∑Ô∏è  Model version: {GLOBAL_MODEL_INFO['model_version']}")
        print(f"   üì¶ Model file: {GLOBAL_MODEL_INFO['model_file']}")
        
        # Try to get actual model info
        self.ml_info_cache = {}
        if ML_PREDICTOR_AVAILABLE:
            try:
                from simple_ml_predictor import get_ml_info
                ml_info = get_ml_info()
                self.ml_info_cache = ml_info  # Cache for later use
                if ml_info.get('ml_loaded'):
                    boot_log_once("ml_model_loaded", f"   ‚úÖ Model loaded: {GLOBAL_MODEL_INFO['model_name']}")
                    boot_log_once("ml_features", f"   üî¢ Features: {GLOBAL_MODEL_INFO['features_count']}")
                    acc = ml_info.get('accuracy')
                    if acc is not None and acc > 0:
                        boot_log_once("ml_accuracy", f"   üéØ Accuracy: {acc:.1%}")
                    else:
                        boot_log_once("ml_accuracy", "   üéØ Accuracy: (offline only)")
            except Exception as e:
                boot_log_once("ml_info_error", f"   ‚ö†Ô∏è  Could not load model info: {e}")

        # Enhanced Policy Bundle v2.0
        # TEMPORALMENTE DESACTIVADO: Tiene errores de API incompatible
        # Los m√©todos .allow(), .size(), .levels() no existen en las clases
        self.enhanced_policy = None
        boot_log_once("policy_status", "\n" + "="*60)
        boot_log_once("policy_header", "üì¶ POLICY ENGINE STATUS")
        boot_log_once("policy_separator", "="*60)
        boot_log_once("policy_state", "Estado general: DESACTIVADO (API incompatible)")
        boot_log_once("policy_fallback", "Fallback activo: Risk Management V2 + ML FASE 2")
        boot_log_once("policy_blocks", "Bloques cr√≠ticos protegidos:")
        boot_log_once("policy_pretrade", " - pre_trade_check_v2 ‚úÖ")
        boot_log_once("policy_exposure", " - exposure / sizing caps ‚úÖ")
        boot_log_once("policy_cooldown", " - cooldown / batching ‚úÖ")
        boot_log_once("policy_end", "="*60 + "\n")
        
        # if ENHANCED_POLICY_AVAILABLE:
        #     try:
        #         self.enhanced_policy = EnhancedPolicyIntegration(self)
        #         if self.enhanced_policy.enabled:
        #             self.enhanced_policy.print_status()
        #     except Exception as e:
        #         print(f"‚ö†Ô∏è  Error inicializando Enhanced Policy: {e}")
        #         self.enhanced_policy = None
        
        # ML retraining scheduler
        self.last_retrain_time = None
        # ‚úÖ PATCH v1.3: Reduced from 12h to 6h for more frequent model updates
        self.retrain_frequency_hours = self.config.get('ml', {}).get('retrain_frequency_hours', 6)
        self.memecoin_take_profit = symbol_config.get('memecoin_take_profit', 0.025) * 100
        self.stable_take_profit = symbol_config.get('stable_take_profit', 0.018) * 100
        
        # Trading state
        self.positions = {}
        self.trade_history = []
        self.daily_pnl = 0.0
        self.trades_today = 0
        self.session_start = datetime.now()
        # Only initialize balance_usdt if in simulation mode
        if self.simulation_mode:
            self.balance_usdt = 1000.0  # Simulated balance
        
        # V2: Initialize Portfolio Tracker for exposure management
        self.portfolio_v2 = None
        if RISK_MANAGEMENT_V2_AVAILABLE:
            try:
                from integration_example_v2 import PortfolioTracker
                initial_equity = self.balance_usdt if self.simulation_mode else 1000.0
                self.portfolio_v2 = PortfolioTracker(initial_equity)
                print("‚úÖ Portfolio Tracker V2 initialized")
            except Exception as e:
                print(f"‚ö†Ô∏è  Portfolio Tracker V2 not available: {e}")
                self.portfolio_v2 = None
        
        # Initialize Symbol Scoring System
        self.symbol_memory = None
        self.scanner_config = None
        self.symbol_themes = {}
        
        if SYMBOL_SCORING_AVAILABLE:
            try:
                # Initialize symbol memory
                self.symbol_memory = SymbolMemory(window_size=50)
                
                # Load scanner configuration
                scanner_config_path = 'config/symbol_scanner.yaml'
                if os.path.exists(scanner_config_path):
                    with open(scanner_config_path, 'r') as f:
                        scanner_data = yaml.safe_load(f)
                        self.scanner_config = scanner_data.get('scanner', {})
                        self.symbol_themes = scanner_data.get('symbol_themes', {})
                    print(f"‚úÖ Symbol Scanner config loaded: {len(self.symbol_themes)} themes")
                else:
                    print(f"‚ö†Ô∏è  Scanner config not found, using defaults")
                    self.scanner_config = {
                        'min_volume_usdt': 15_000_000,
                        'max_spread_bps': 8,
                        'top_k': 18,
                        'max_per_cluster': 2
                    }
            except Exception as e:
                print(f"‚ö†Ô∏è  Symbol Scoring System initialization error: {e}")
                self.symbol_memory = None
        
        # ‚úÖ MEJORA 1: Trailing Stop Manager (solo HIGH regime)
        self.trailing_stop_manager = None
        try:
            from risk.trailing_stop import TrailingStopManager
            self.trailing_stop_manager = TrailingStopManager()
            print("‚úÖ Trailing Stop Manager inicializado (HIGH regime)")
        except ImportError as e:
            print(f"‚ö†Ô∏è  Trailing Stop Manager no disponible: {e}")
        
        # ‚úÖ MEJORA 2: Conditional Threshold Manager
        self.conditional_threshold_manager = None
        try:
            from signals.conditional_threshold import ConditionalThresholdManager
            self.conditional_threshold_manager = ConditionalThresholdManager(base_threshold=0.75)
            print("‚úÖ Conditional Threshold Manager inicializado")
        except ImportError as e:
            print(f"‚ö†Ô∏è  Conditional Threshold Manager no disponible: {e}")
        
        # ‚úÖ MEJORA 5: Throughput Health Metrics
        self.throughput_health = None
        try:
            from metrics.throughput_health import ThroughputHealthMetrics
            self.throughput_health = ThroughputHealthMetrics()
            print("‚úÖ Throughput Health Metrics inicializado")
        except ImportError as e:
            print(f"‚ö†Ô∏è  Throughput Health Metrics no disponible: {e}")
        
        # Conservative position sizing tracking
        self.consecutive_losses = 0  # Track losing streak for position reduction
        self.consecutive_wins = 0    # Track winning streak for potential scaling
        
        # CIRCUIT BREAKER STATE - OPTIMIZADO POR ANALYTICS ENGINE
        self.emergency_mode = False
        self.emergency_start_time = None
        
        # ML Performance tracking
        self.ml_predictions = []
        self.ml_accuracy_window = 50  # Last 50 trades for accuracy calculation
        
        # ML Decision tracking for status reporting
        self.ml_decision_stats = {
            'enhanced': 0,
            'basic': 0,
            'basic_ml': 0,  # Track basic ML fallback separately
            'none': 0,
            'market_analysis': 0,
            'base_score': 0,
            'total_decisions': 0,
            'last_reset': get_utc_now()
        }
        
        # Performance metrics tracking for 24h window
        self.performance_metrics_24h = {
            'confidence_readings': [],  # List of (timestamp, confidence) tuples
            'decisions': [],  # List of (timestamp, confidence, signal_used)
            'decision_counts': defaultdict(int),
            'staleness_events': [],  # List of staleness penalty events
            'start_time': get_utc_now(),
            'last_cleanup': get_utc_now()
        }
        
        # Recent events storage (last 5 events for each type)
        self.recent_events = {
            'reloads': [],  # Model reload events
            'fallbacks': [],  # Enhanced->Basic fallback events
            'conservative_mode': [],  # Conservative mode activation/deactivation
            'staleness_penalties': [],  # Data staleness penalty events
            'errors': []  # ML-related errors
        }
        
        # Enhanced Error Handler
        self.error_handler = None
        self.balance_manager = None        
        # Enhanced ML Storage
        self.enhanced_storage = None
        if ENHANCED_STORAGE_AVAILABLE:
            try:
                self.enhanced_storage = EnhancedMLStorage()
                print("‚úÖ Enhanced ML Storage inicializado")
            except Exception as e:
                print(f"‚ö†Ô∏è  Error inicializando Enhanced ML Storage: {e}")
                self.enhanced_storage = None
        if ENHANCED_ERROR_HANDLER_AVAILABLE:
            self.error_handler, self.balance_manager = integrate_enhanced_error_handling(self)
            print("‚úÖ Enhanced Error Handler activado")
        
        # Setup ML predictor position tracker for safe reload window
        if ML_PREDICTOR_AVAILABLE:
            try:
                set_position_tracker(self.get_open_positions_count)
                print("‚úÖ ML Predictor position tracker configurado")
            except Exception as e:
                print(f"‚ö†Ô∏è  Error configurando position tracker: {e}")
        
        # Staleness control configuration from config
        data_sources_config = self.config.get('data_sources', {})
        staleness_config = data_sources_config.get('staleness_config', {})
        
        # Data source enabled flags
        self.sentiment_enabled = data_sources_config.get('sentiment_enabled', True)
        self.copy_enabled = data_sources_config.get('copy_enabled', True)
        self.market_enabled = data_sources_config.get('market_enabled', True)
        
        # Staleness thresholds - OPTIMIZED VALUES (PATCH v1.4)
        self.staleness_config = {
            'market_data_ttl_minutes': staleness_config.get('market_data_ttl_minutes', 360),  # ‚úÖ PATCH v1.4: Increased to 360 min (6h)
            'sentiment_ttl_minutes': staleness_config.get('sentiment_ttl_minutes', 1440),    # Increased to 1440 (24h)
            'copy_trading_ttl_minutes': staleness_config.get('copy_trading_ttl_minutes', 1440),  # Increased to 1440 (24h)
            'hard_limit_hours': staleness_config.get('hard_limit_hours', 48),  # Increased to 48h
            'soft_penalty_factor': staleness_config.get('soft_penalty_factor', 0.995)  # ‚úÖ PATCH v1.4: Relaxed to 0.995 (0.5% penalty)
        }
        
        # Initialize data timestamps
        self.last_data_timestamps = {
            'market': get_utc_now(),
            'sentiment': get_utc_now() - timedelta(hours=1),  # Simular edad inicial
            'copy_trading': get_utc_now() - timedelta(hours=2)
        }
        
        # Conservative mode tracking - RELAXED SETTINGS
        self.conservative_mode_state = {
            'active': False,
            'critical_checks_count': 0,
            'last_critical_check': None,
            'activation_time': None,
            'threshold_boost': 0.02,  # Reduced from 0.05 to 0.02
            'position_reduction': 0.10,  # Reduced from 0.30 to 0.10 (10% instead of 30%)
            'recovery_threshold': 0.57,  # Lowered from 0.60 to 0.57
            'recovery_checks_needed': 2  # Reduced from 3 to 2 consecutive checks
        }
        
        # Alert debounce system - limit CRITICAL alerts to max 1 every 30 minutes per cause
        self.alert_debounce = {
            'last_alerts': {},  # {alert_type: timestamp}
            'debounce_minutes': 30,
            'suppressed_count': {}  # {alert_type: count}
        }
        
        # Continuous monitoring system - integrated into existing loop
        self.continuous_monitoring = {
            'last_calculation': get_utc_now(),
            'calculation_interval_minutes': 15,
            'recovery_threshold': 0.35,  # low_conf_ratio_1h > 0.35 triggers recovery
            'recovery_active': False,
            'last_recovery_trigger': None
        }
        
        # Initialize exchange if not in simulation mode
        if not self.simulation_mode:
            try:
                self.exchange = ccxt.binance({
                    'apiKey': self.api_key,
                    'secret': self.api_secret,
                    'sandbox': self.testnet,
                    'enableRateLimit': True,
                    'options': {'defaultType': 'spot'}
                })
                print("‚úÖ Conexi√≥n a Binance inicializada")
            except Exception as e:
                print(f"‚ùå Error conectando a Binance: {e}")
                print("‚ö†Ô∏è  CONTINUANDO EN MODO SIMULACI√ìN...")
                self.simulation_mode = True
        
        # ML Status Card - Tarjeta de estado inicial (despu√©s de toda la inicializaci√≥n)
        self._print_ml_status_card()
    
    def check_safe_mode(self, final_confidence):
        """
        ‚úÖ PATCH v1.4 ‚Äì Smart Safe Mode with auto-unlock and auto-reactivation
        
        Desactiva Safe Mode si:
        1. Confianza instant√°nea > 0.70, O
        2. Media m√≥vil de √∫ltimas 6 lecturas > 0.80
        
        Reactiva Safe Mode si:
        - Media m√≥vil cae por debajo de 0.60
        
        Args:
            final_confidence (float): Confianza final de la predicci√≥n ML
            
        Returns:
            bool: True si safe_mode debe permanecer activo, False si debe desactivarse
        """
        # Agregar confianza al historial (siempre, incluso si safe_mode est√° off)
        if final_confidence > 0:
            self.safe_mode_unlock_tracker['confidence_history'].append(final_confidence)
            
            # ‚úÖ PATCH v1.4: Ventana m√°s grande para mejor estabilidad (6 lecturas)
            window_size = 6
            if len(self.safe_mode_unlock_tracker['confidence_history']) > window_size:
                self.safe_mode_unlock_tracker['confidence_history'] = \
                    self.safe_mode_unlock_tracker['confidence_history'][-window_size:]
        
        history = self.safe_mode_unlock_tracker['confidence_history']
        
        # Si Safe Mode est√° activo, evaluar desactivaci√≥n
        if self.safe_mode:
            # M√©todo 1: Confianza instant√°nea muy alta
            if final_confidence > 0.70:
                print(f'üü¢ Safe Mode desactivado (confianza instant√°nea={final_confidence:.3f})')
                return False
            
            # M√©todo 2: Media m√≥vil sostenida alta
            if len(history) >= 6:
                avg_confidence = sum(history) / len(history)
                
                # ‚úÖ PATCH v1.4: Umbral m√°s alto (0.80) para mayor confianza
                if avg_confidence >= 0.80:
                    print(f'üü¢ Safe Mode desactivado (avg_6={avg_confidence:.3f} ‚â• 0.80)')
                    return False
            
            return True  # Mantener Safe Mode activo
        
        # ‚úÖ PATCH v1.4: Si Safe Mode est√° inactivo, evaluar reactivaci√≥n
        else:
            if len(history) >= 6:
                avg_confidence = sum(history) / len(history)
                
                # Reactivar si confianza cae significativamente
                if avg_confidence < 0.60:
                    print(f'üü° Safe Mode reactivado (avg_6={avg_confidence:.3f} < 0.60)')
                    return True
            
            return False  # Mantener Safe Mode inactivo
    
    def log_ml_decision(self, signal_used, final_confidence, effective_threshold, 
                       reason_for_bypass=None, symbol=None, trade_decision=None):
        """
        Log structured ML decision with all required fields in key=value format
        Compatible with existing pipeline
        """
        utc_now = get_utc_now()
        
        # Track decision statistics for ML status reporting
        if signal_used in self.ml_decision_stats:
            self.ml_decision_stats[signal_used] += 1
        self.ml_decision_stats['total_decisions'] += 1
        
        # Track performance metrics for 24h window
        if final_confidence > 0:  # Only track valid confidence readings
            self._add_performance_metric(final_confidence)
        
        # Track decision counts for 24h performance
        self.performance_metrics_24h['decision_counts'][signal_used] += 1
        
        # Clean up old metrics periodically
        self._cleanup_old_metrics()
        
        # Get ML model information from MODEL_RUNTIME_ID (single source of truth)
        ml_loaded = ML_PREDICTOR_AVAILABLE
        model_runtime_id = MODEL_RUNTIME_ID if MODEL_RUNTIME_ID else "unknown|unknown"
        
        # Calculate data staleness in minutes
        sentiment_age_min = self._calculate_data_age_minutes('sentiment')
        copy_age_min = self._calculate_data_age_minutes('copy_trading')
        market_age_min = self._calculate_data_age_minutes('market')
        
        # Build structured log entry
        log_parts = [
            f"timestamp={utc_now.isoformat()}",
            f"signal_used={signal_used}",
            f"final_confidence={final_confidence:.3f}",
            f"effective_threshold={effective_threshold:.3f}",
            f"ml_loaded={ml_loaded}",
            f"model_runtime_id={model_runtime_id}",
            f"sentiment_age_min={sentiment_age_min}",
            f"copy_age_min={copy_age_min}",
            f"market_age_min={market_age_min}"
        ]
        
        if reason_for_bypass:
            if isinstance(reason_for_bypass, BypassReason):
                log_parts.append(f"reason_for_bypass={reason_for_bypass.value}")
            else:
                log_parts.append(f"reason_for_bypass={reason_for_bypass}")
        
        if symbol:
            log_parts.append(f"symbol={symbol}")
            
        if trade_decision:
            log_parts.append(f"trade_decision={trade_decision}")
        
        # Log in single line with key=value format
        log_line = "üîç ML_DECISION: " + ", ".join(log_parts)
        print(log_line)
    
    def _calculate_data_age_minutes(self, source):
        """Calculate data age in minutes using UTC as source of truth"""
        utc_now = get_utc_now()
        
        if source in self.last_data_timestamps:
            last_update = self.last_data_timestamps[source]
            # Convert to UTC if not already
            if last_update.tzinfo is None:
                last_update = last_update.replace(tzinfo=timezone.utc)
            
            age_seconds = (utc_now - last_update).total_seconds()
            return int(age_seconds / 60)
        
        return 999  # Unknown age
    
    def _add_performance_metric(self, confidence):
        """Add confidence reading to 24h performance tracking"""
        utc_now = get_utc_now()
        self.performance_metrics_24h['confidence_readings'].append((utc_now, confidence))
        
        # Clean up old readings (older than 24h)
        cutoff_time = utc_now - timedelta(hours=24)
        self.performance_metrics_24h['confidence_readings'] = [
            (ts, conf) for ts, conf in self.performance_metrics_24h['confidence_readings']
            if ts > cutoff_time
        ]
    
    def _add_recent_event(self, event_type, event_data):
        """Add event to recent events storage, keeping only last 5 of each type"""
        utc_now = get_utc_now()
        
        event_entry = {
            'timestamp': utc_now,
            'data': event_data
        }
        
        if event_type in self.recent_events:
            self.recent_events[event_type].append(event_entry)
            # Keep only last 5 events
            self.recent_events[event_type] = self.recent_events[event_type][-5:]
    
    def add_decision(self, confidence, signal='hold', signal_used='unknown'):
        """
        üîß PATCH v1.5 - Fix #5: Add decision to 24h tracking for continuous monitoring
        
        This ensures the continuous monitor has data to analyze (readings_count > 0)
        """
        utc_now = get_utc_now()
        self.performance_metrics_24h['decisions'].append({
            'timestamp': utc_now,
            'confidence': confidence,
            'signal': signal,
            'signal_used': signal_used
        })
        
        # Clean up old decisions (older than 24h)
        cutoff_time = utc_now - timedelta(hours=24)
        self.performance_metrics_24h['decisions'] = [
            d for d in self.performance_metrics_24h['decisions']
            if d['timestamp'] > cutoff_time
        ]
    
    def _cleanup_old_metrics(self):
        """Clean up old performance metrics (called periodically)"""
        utc_now = get_utc_now()
        
        # Clean up every hour
        if (utc_now - self.performance_metrics_24h['last_cleanup']).total_seconds() > 3600:
            cutoff_time = utc_now - timedelta(hours=24)
            
            # Clean confidence readings
            self.performance_metrics_24h['confidence_readings'] = [
                (ts, conf) for ts, conf in self.performance_metrics_24h['confidence_readings']
                if ts > cutoff_time
            ]
            
            # Clean staleness events
            self.performance_metrics_24h['staleness_events'] = [
                event for event in self.performance_metrics_24h['staleness_events']
                if event['timestamp'] > cutoff_time
            ]
            
            self.performance_metrics_24h['last_cleanup'] = utc_now
    
    def calculate_continuous_monitoring_metrics(self):
        """
        Calculate ML performance metrics every 15 minutes for continuous monitoring.
        Detects low_conf_ratio_1h > 0.35 to trigger recovery.
        Maintains metrics in memory, reuses existing infrastructure.
        
        Requirements: 1.1, 1.2, 1.3, 2.1
        """
        utc_now = get_utc_now()
        
        # Check if it's time to calculate (every 15 minutes)
        time_since_last = (utc_now - self.continuous_monitoring['last_calculation']).total_seconds()
        interval_seconds = self.continuous_monitoring['calculation_interval_minutes'] * 60
        
        if time_since_last < interval_seconds:
            return  # Not time yet
        
        # Update last calculation time
        self.continuous_monitoring['last_calculation'] = utc_now
        
        # Get confidence readings from last hour using decisions as base structure
        one_hour_ago = utc_now - timedelta(hours=1)
        decisions = self.performance_metrics_24h.get('decisions', [])
        
        # Filter to last hour only and extract confidence values
        recent_readings = [
            (d['timestamp'], d['confidence']) for d in decisions 
            if d['timestamp'] > one_hour_ago and d.get('confidence', 0) > 0
        ]
        
        if not recent_readings:
            print(f"üîç CONTINUOUS_MONITOR: timestamp={utc_now.isoformat()}, "
                  f"ml_conf_avg_1h=0.0, low_conf_ratio_1h=0.0, "
                  f"readings_count=0, status=insufficient_data")
            return
        
        # Calculate ml_conf_avg_1h
        confidences = [conf for _, conf in recent_readings]
        ml_conf_avg_1h = sum(confidences) / len(confidences)
        
        # Calculate low_conf_ratio_1h (percentage of predictions with confidence < 0.50)
        low_conf_count = sum(1 for conf in confidences if conf < 0.50)
        low_conf_ratio_1h = low_conf_count / len(confidences)
        
        # Log structured monitoring metrics
        print(f"üîç CONTINUOUS_MONITOR: timestamp={utc_now.isoformat()}, "
              f"ml_conf_avg_1h={ml_conf_avg_1h:.3f}, "
              f"low_conf_ratio_1h={low_conf_ratio_1h:.3f}, "
              f"readings_count={len(confidences)}, "
              f"calculation_interval_min={self.continuous_monitoring['calculation_interval_minutes']}")
        
        # Check if recovery should be triggered
        recovery_threshold = self.continuous_monitoring['recovery_threshold']
        
        if low_conf_ratio_1h > recovery_threshold:
            # Trigger recovery if not already active
            if not self.continuous_monitoring['recovery_active']:
                self.continuous_monitoring['recovery_active'] = True
                self.continuous_monitoring['last_recovery_trigger'] = utc_now
                
                print(f"üî¥ CONTINUOUS_MONITOR: recovery_triggered=true, "
                      f"low_conf_ratio_1h={low_conf_ratio_1h:.3f}, "
                      f"recovery_threshold={recovery_threshold:.3f}, "
                      f"ml_conf_avg_1h={ml_conf_avg_1h:.3f}, "
                      f"trigger_reason=high_low_confidence_ratio")
                
                # Log structured recovery trigger
                self.log_ml_decision(
                    signal_used="continuous_monitor",
                    final_confidence=ml_conf_avg_1h,
                    effective_threshold=recovery_threshold,
                    reason_for_bypass=BypassReason.THRESHOLD,
                    trade_decision="recovery_triggered"
                )
                
                # Add to recent events
                self._add_recent_event('recovery_triggers', {
                    'ml_conf_avg_1h': ml_conf_avg_1h,
                    'low_conf_ratio_1h': low_conf_ratio_1h,
                    'recovery_threshold': recovery_threshold,
                    'readings_count': len(confidences)
                })
                
                # Apply debounced alert for recovery trigger
                if self.should_send_alert('ml_recovery_trigger'):
                    print(f"üö® ALERT: ML Recovery triggered - Low confidence ratio: {low_conf_ratio_1h:.1%} > {recovery_threshold:.1%}")
            else:
                # Recovery already active, just log status
                time_since_trigger = utc_now - self.continuous_monitoring['last_recovery_trigger']
                print(f"üîç CONTINUOUS_MONITOR: recovery_active=true, "
                      f"duration_minutes={time_since_trigger.total_seconds()/60:.1f}, "
                      f"low_conf_ratio_1h={low_conf_ratio_1h:.3f}")
        else:
            # Check if recovery should be deactivated
            if self.continuous_monitoring['recovery_active']:
                self.continuous_monitoring['recovery_active'] = False
                
                print(f"üü¢ CONTINUOUS_MONITOR: recovery_deactivated=true, "
                      f"low_conf_ratio_1h={low_conf_ratio_1h:.3f}, "
                      f"recovery_threshold={recovery_threshold:.3f}, "
                      f"ml_conf_avg_1h={ml_conf_avg_1h:.3f}, "
                      f"recovery_reason=confidence_improved")
                
                # Log structured recovery deactivation
                self.log_ml_decision(
                    signal_used="continuous_monitor",
                    final_confidence=ml_conf_avg_1h,
                    effective_threshold=recovery_threshold,
                    trade_decision="recovery_deactivated"
                )
        
        # Store current metrics for status reporting
        self.continuous_monitoring['last_ml_conf_avg_1h'] = ml_conf_avg_1h
        self.continuous_monitoring['last_low_conf_ratio_1h'] = low_conf_ratio_1h
        self.continuous_monitoring['last_readings_count'] = len(confidences)
        
        # Update monitoring status card every hour
        if not hasattr(self, '_last_status_update') or \
           (utc_now - self._last_status_update).total_seconds() > 3600:
            self._print_monitoring_status_update()
            self._last_status_update = utc_now
    
    def is_enhanced_ml_available(self):
        """
        Check if enhanced ML is currently available and functional.
        
        Returns:
            bool: True if enhanced ML is available and working
        """
        if not ENHANCED_ML_AVAILABLE:
            return False
            
        try:
            # Try a quick test call to see if enhanced ML is working
            from offline_enhanced_ml import get_offline_enhanced_prediction
            # Just check if the function is importable and callable
            return callable(get_offline_enhanced_prediction)
        except Exception:
            return False
    
    def apply_staleness_penalty(self, confidence, symbol=None):
        """
        Apply staleness penalties to ML confidence based on data source ages.
        
        Args:
            confidence (float): Original ML confidence
            symbol (str, optional): Trading symbol for logging
            
        Returns:
            tuple: (penalized_confidence, bypass_reason or None)
        """
        utc_now = get_utc_now()
        original_confidence = confidence
        bypass_reason = None
        penalties_applied = []
        
        # Check each enabled data source
        sources_to_check = []
        if self.market_enabled:
            sources_to_check.append(('market', self.staleness_config['market_data_ttl_minutes']))
        if self.sentiment_enabled:
            sources_to_check.append(('sentiment', self.staleness_config['sentiment_ttl_minutes']))
        if self.copy_enabled:
            sources_to_check.append(('copy_trading', self.staleness_config['copy_trading_ttl_minutes']))
        
        # Apply penalties for each stale source
        for source, ttl_minutes in sources_to_check:
            age_minutes = self._calculate_data_age_minutes(source)
            
            # Hard limit check (24 hours = 1440 minutes)
            hard_limit_minutes = self.staleness_config['hard_limit_hours'] * 60
            if age_minutes > hard_limit_minutes:
                # Force HOLD for critical staleness
                self.log_ml_decision(
                    signal_used="none",
                    final_confidence=0.0,
                    effective_threshold=0.0,
                    reason_for_bypass=BypassReason.STALE_DATA_HARD_LIMIT,
                    symbol=symbol,
                    trade_decision="hold"
                )
                print(f"üîç ML_STALENESS: hard_limit_triggered, source={source}, "
                      f"age_minutes={age_minutes}, limit_minutes={hard_limit_minutes}, "
                      f"confidence=0.0, symbol={symbol or 'none'}, decision=HOLD_por_staleness")
                # ‚úÖ FIX #2: Return inmediato para forzar HOLD y explicar el motivo
                return 0.0, f"hard_stale_{source}"
            
            # Soft penalty check
            if age_minutes > ttl_minutes:
                confidence *= self.staleness_config['soft_penalty_factor']
                penalties_applied.append(f"{source}:{age_minutes}min")
                
                print(f"üîç ML_STALENESS: stale_penalty_applied=true, source={source}, "
                      f"age_minutes={age_minutes}, ttl_minutes={ttl_minutes}, "
                      f"penalty_factor={self.staleness_config['soft_penalty_factor']}, "
                      f"confidence_before={original_confidence:.3f}, "
                      f"confidence_after={confidence:.3f}")
        
        # Log staleness penalty if any were applied
        if penalties_applied:
            bypass_reason = BypassReason.STALE_DATA_SOFT
            print(f"üîç ML_STALENESS: penalties_summary, "
                  f"sources_penalized={','.join(penalties_applied)}, "
                  f"original_confidence={original_confidence:.3f}, "
                  f"final_confidence={confidence:.3f}, "
                  f"symbol={symbol or 'none'}")
            
            # Track staleness event for 24h metrics
            staleness_event = {
                'timestamp': utc_now,
                'sources_penalized': penalties_applied,
                'original_confidence': original_confidence,
                'final_confidence': confidence,
                'symbol': symbol
            }
            self.performance_metrics_24h['staleness_events'].append(staleness_event)
            
            # Add to recent events
            self._add_recent_event('staleness_penalties', {
                'sources': penalties_applied,
                'confidence_impact': f"{original_confidence:.3f} -> {confidence:.3f}",
                'symbol': symbol or 'none'
            })
        
        return confidence, bypass_reason
    
    def should_send_alert(self, alert_type):
        """
        Check if alert should be sent based on debounce rules.
        Limits CRITICAL alerts to maximum 1 every 30 minutes per cause.
        
        Args:
            alert_type (str): Type of alert (e.g., 'ml_confidence_critical', 'staleness_critical')
            
        Returns:
            bool: True if alert should be sent, False if suppressed
        """
        utc_now = get_utc_now()
        
        # Check if we have sent this alert type recently
        last_alert_time = self.alert_debounce['last_alerts'].get(alert_type)
        
        if last_alert_time:
            time_since_last = (utc_now - last_alert_time).total_seconds() / 60  # minutes
            
            if time_since_last < self.alert_debounce['debounce_minutes']:
                # Suppress alert - increment counter
                self.alert_debounce['suppressed_count'][alert_type] = \
                    self.alert_debounce['suppressed_count'].get(alert_type, 0) + 1
                
                # Log suppression with structured format
                print(f"üîç ML_DECISION: timestamp={utc_now.isoformat()}, "
                      f"signal_used=alert_system, final_confidence=0.0, "
                      f"effective_threshold=0.0, reason_for_bypass=threshold, "
                      f"alert_suppressed=true, alert_type={alert_type}, "
                      f"suppressed_count={self.alert_debounce['suppressed_count'][alert_type]}, "
                      f"time_since_last_min={time_since_last:.1f}")
                
                return False
        
        # Send alert - update timestamp
        self.alert_debounce['last_alerts'][alert_type] = utc_now
        
        # Reset suppressed count for this alert type
        if alert_type in self.alert_debounce['suppressed_count']:
            suppressed_total = self.alert_debounce['suppressed_count'][alert_type]
            if suppressed_total > 0:
                # Log that we're now sending after suppression with structured format
                print(f"üîç ML_DECISION: timestamp={utc_now.isoformat()}, "
                      f"signal_used=alert_system, final_confidence=0.0, "
                      f"effective_threshold=0.0, reason_for_bypass=threshold, "
                      f"alert_sent_after_suppression=true, alert_type={alert_type}, "
                      f"total_suppressed={suppressed_total}")
            self.alert_debounce['suppressed_count'][alert_type] = 0
        
        return True

    def check_conservative_mode_trigger(self, ml_confidence):
        """
        Check if conservative mode should be triggered based on consecutive critical ML confidence checks.
        
        Args:
            ml_confidence (float): Current ML confidence score
            
        Returns:
            bool: True if conservative mode state changed
        """
        utc_now = get_utc_now()
        critical_threshold = 0.50
        state_changed = False
        
        # Check if this is a critical confidence reading
        if ml_confidence < critical_threshold:
            # Update critical check tracking
            self.conservative_mode_state['critical_checks_count'] += 1
            self.conservative_mode_state['last_critical_check'] = utc_now
            
            # Check if we should activate conservative mode (3 consecutive critical checks)
            if (not self.conservative_mode_state['active'] and 
                self.conservative_mode_state['critical_checks_count'] >= 3):
                
                self.conservative_mode_state['active'] = True
                self.conservative_mode_state['activation_time'] = utc_now
                state_changed = True
                
                # Apply debounce to conservative mode activation alert
                if self.should_send_alert('conservative_mode_activation'):
                    print(f"üî¥ CONSERVATIVE_MODE: activated=true, trigger_count=3, "
                          f"ml_confidence={ml_confidence:.3f}, critical_threshold={critical_threshold:.3f}, "
                          f"threshold_boost={self.conservative_mode_state['threshold_boost']:.3f}, "
                          f"position_reduction={self.conservative_mode_state['position_reduction']:.1%}")
                
                # Log structured conservative mode activation
                self.log_ml_decision(
                    signal_used="conservative_mode",
                    final_confidence=ml_confidence,
                    effective_threshold=critical_threshold,
                    reason_for_bypass=BypassReason.THRESHOLD,
                    trade_decision="conservative_activated"
                )
        else:
            # Good confidence reading - check for recovery
            if self.conservative_mode_state['active']:
                # Reset critical check counter on good reading
                self.conservative_mode_state['critical_checks_count'] = 0
                
                # Check if confidence is good enough for recovery
                recovery_threshold = self.conservative_mode_state['recovery_threshold']
                if ml_confidence >= recovery_threshold:
                    # Deactivate conservative mode
                    self.conservative_mode_state['active'] = False
                    self.conservative_mode_state['critical_checks_count'] = 0
                    self.conservative_mode_state['activation_time'] = None
                    state_changed = True
                    
                    print(f"üü¢ CONSERVATIVE_MODE: deactivated=true, recovery_confidence={ml_confidence:.3f}, "
                          f"recovery_threshold={recovery_threshold:.3f}, "
                          f"performance_improved=true")
                    
                    # Log structured conservative mode deactivation
                    self.log_ml_decision(
                        signal_used="conservative_mode",
                        final_confidence=ml_confidence,
                        effective_threshold=recovery_threshold,
                        trade_decision="conservative_deactivated"
                    )
            else:
                # Not in conservative mode, reset counter on good reading
                self.conservative_mode_state['critical_checks_count'] = 0
        
        return state_changed
    
    def _add_event(self, event_type, event_data):
        """Add event to recent events tracking (keep last 5)"""
        if event_type not in self.recent_events:
            self.recent_events[event_type] = []
        
        event_data['timestamp'] = get_utc_now()
        self.recent_events[event_type].append(event_data)
        
        # Keep only last 5 events
        if len(self.recent_events[event_type]) > 5:
            self.recent_events[event_type] = self.recent_events[event_type][-5:]
    

    

    
    def apply_conservative_mode_adjustments(self, effective_threshold, position_size):
        """
        Apply conservative mode adjustments to threshold and position size.
        
        Args:
            effective_threshold (float): Original effective threshold
            position_size (float): Original position size
            
        Returns:
            tuple: (adjusted_threshold, adjusted_position_size)
        """
        if not self.conservative_mode_state['active']:
            return effective_threshold, position_size
        
        # Apply conservative adjustments
        adjusted_threshold = effective_threshold + self.conservative_mode_state['threshold_boost']
        adjusted_position_size = position_size * (1 - self.conservative_mode_state['position_reduction'])
        
        # Ensure threshold stays within bounds
        adjusted_threshold = min(adjusted_threshold, 0.95)
        
        # Apply debounce to conservative adjustments alert
        if self.should_send_alert('conservative_adjustments'):
            print(f"üî¥ CONSERVATIVE_ADJUSTMENTS: threshold_original={effective_threshold:.3f}, "
                  f"threshold_adjusted={adjusted_threshold:.3f}, "
                  f"position_original=${position_size:.2f}, "
                  f"position_adjusted=${adjusted_position_size:.2f}")
        
        return adjusted_threshold, adjusted_position_size
    
    def _print_ml_status_card(self):
        """Imprime tarjeta de estado ML al inicio con informaci√≥n de monitoreo continuo"""
        utc_now = get_utc_now()
        
        print(f"\nüîç ML_TRACE: ml_status_card, timestamp={utc_now.isoformat()}")
        print(f"üîç ML_TRACE: ml_loaded={ML_PREDICTOR_AVAILABLE}, enhanced_ml={ENHANCED_ML_AVAILABLE}, "
              f"enhanced_storage={ENHANCED_STORAGE_AVAILABLE}")
        
        if ML_PREDICTOR_AVAILABLE:
            try:
                # Use GLOBAL_MODEL_INFO as single source of truth
                model_hash_short = GLOBAL_MODEL_INFO['model_hash'][:8] if GLOBAL_MODEL_INFO['model_hash'] != 'unknown' else 'unknown'
                print(f"üîç ML_TRACE: model_name={GLOBAL_MODEL_INFO['model_name']}, "
                      f"model_version={GLOBAL_MODEL_INFO['model_version']}, "
                      f"model_hash={model_hash_short}, "
                      f"model_loaded_at={GLOBAL_MODEL_INFO['model_loaded_at']}")
            except Exception as e:
                print(f"üîç ML_TRACE: ml_info_error='{str(e)}'")
        
        storage_status = "on" if self.enhanced_storage else "off"
        print(f"üîç ML_TRACE: storage={storage_status}, sentiment_enabled={self.use_sentiment_analysis}, "
              f"copytrading_enabled=True")
        
        # Add conservative mode status to ML status card
        conservative_active = self.conservative_mode_state['active']
        print(f"üîç ML_TRACE: conservative_mode_active={conservative_active}")
        if conservative_active:
            activation_time = self.conservative_mode_state['activation_time']
            print(f"üîç ML_TRACE: conservative_activated_at={activation_time.isoformat() if activation_time else 'unknown'}")
        
        # Add continuous monitoring status
        monitoring = self.continuous_monitoring
        print(f"üîç ML_TRACE: continuous_monitoring_enabled=true, "
              f"calculation_interval_min={monitoring['calculation_interval_minutes']}, "
              f"recovery_threshold={monitoring['recovery_threshold']:.3f}")
        
        print(f"üîç ML_TRACE: recovery_active={monitoring['recovery_active']}")
        if monitoring['recovery_active'] and monitoring['last_recovery_trigger']:
            duration_min = (utc_now - monitoring['last_recovery_trigger']).total_seconds() / 60
            print(f"üîç ML_TRACE: recovery_duration_min={duration_min:.1f}, "
                  f"recovery_triggered_at={monitoring['last_recovery_trigger'].isoformat()}")
        
        # Add recent monitoring metrics if available
        if hasattr(self, 'continuous_monitoring') and 'last_ml_conf_avg_1h' in monitoring:
            print(f"üîç ML_TRACE: last_ml_conf_avg_1h={monitoring.get('last_ml_conf_avg_1h', 0.0):.3f}, "
                  f"last_low_conf_ratio_1h={monitoring.get('last_low_conf_ratio_1h', 0.0):.3f}, "
                  f"last_readings_count={monitoring.get('last_readings_count', 0)}")
        
        # Add alert debounce system status
        alert_count = len(self.alert_debounce['last_alerts'])
        print(f"üîç ML_TRACE: alert_debounce_active=true, "
              f"debounce_window_min={self.alert_debounce['debounce_minutes']}, "
              f"active_alert_types={alert_count}")
        
        # Add performance metrics status
        if hasattr(self, 'performance_metrics_24h'):
            metrics_age_hours = (utc_now - self.performance_metrics_24h.get('last_cleanup', utc_now)).total_seconds() / 3600
            print(f"üîç ML_TRACE: performance_metrics_24h_enabled=true, "
                  f"metrics_age_hours={metrics_age_hours:.1f}, "
                  f"cleanup_interval_hours=24")

    def _print_monitoring_status_update(self):
        """Imprime actualizaci√≥n de estado de monitoreo cada hora"""
        utc_now = get_utc_now()
        monitoring = self.continuous_monitoring
        
        print(f"\nüìä MONITORING_STATUS_UPDATE: timestamp={utc_now.isoformat()}")
        
        # Current monitoring metrics
        if 'last_ml_conf_avg_1h' in monitoring:
            print(f"üìä MONITORING_STATUS: ml_conf_avg_1h={monitoring['last_ml_conf_avg_1h']:.3f}, "
                  f"low_conf_ratio_1h={monitoring['last_low_conf_ratio_1h']:.3f}, "
                  f"readings_count_1h={monitoring['last_readings_count']}")
        
        # Recovery system status
        recovery_status = "active" if monitoring['recovery_active'] else "inactive"
        print(f"üìä MONITORING_STATUS: recovery_system={recovery_status}, "
              f"recovery_threshold={monitoring['recovery_threshold']:.3f}")
        
        if monitoring['recovery_active'] and monitoring['last_recovery_trigger']:
            duration_hours = (utc_now - monitoring['last_recovery_trigger']).total_seconds() / 3600
            print(f"üìä MONITORING_STATUS: recovery_duration_hours={duration_hours:.2f}")
        
        # Conservative mode status
        conservative_status = "active" if self.conservative_mode_state['active'] else "inactive"
        print(f"üìä MONITORING_STATUS: conservative_mode={conservative_status}")
        
        # Alert system status
        recent_alerts = sum(1 for timestamp in self.alert_debounce['last_alerts'].values() 
                          if (utc_now - timestamp).total_seconds() < 3600)
        print(f"üìä MONITORING_STATUS: alerts_last_hour={recent_alerts}, "
              f"debounce_active_types={len(self.alert_debounce['last_alerts'])}")
        
        # Performance metrics summary
        if hasattr(self, 'performance_metrics_24h'):
            total_decisions = len(self.performance_metrics_24h.get('ml_decisions', []))
            print(f"üìä MONITORING_STATUS: ml_decisions_24h={total_decisions}")
        
        # System health indicators
        ml_health = "healthy" if ML_PREDICTOR_AVAILABLE else "degraded"
        storage_health = "healthy" if self.enhanced_storage else "basic"
        print(f"üìä MONITORING_STATUS: ml_system_health={ml_health}, "
              f"storage_system_health={storage_health}")

    def load_optimized_config(self):
        """Load optimized configuration"""
        try:
            with open('config/bot_config.json', 'r') as f:
                config = json.load(f)
            print("‚úÖ Configuraci√≥n optimizada cargada")
            return config
        except Exception as e:
            print(f"‚ö†Ô∏è  Usando configuraci√≥n por defecto: {e}")
            return {
                'trading': {
                    'take_profit_percent': 0.020,
                    'stop_loss_percent': 0.012,
                    'min_confidence': 0.65,
                    'max_position_percent': 0.15,
                    'analysis_frequency_seconds': 90,
                    'daily_analysis_enabled': True,
                    'max_daily_symbols': 12,
                    'min_volume_usdt': 1000000
                }
            }
    
    def load_safe_mode_config(self):
        """Load safe mode configuration if exists"""
        try:
            with open('config/safe_mode_config.json', 'r') as f:
                config = json.load(f)
            print("‚úÖ Configuraci√≥n de modo seguro cargada")
            return config
        except Exception as e:
            return None
    
    def compute_effective_threshold(self, enhanced=True, symbol=None, regime=None):
        """
        Compute effective confidence threshold based on config, safe mode, and symbol-specific rules.
        UNIFIED VERSION - Single implementation for all cases
        
        ‚úÖ MEJORA 2: Integra conditional threshold para HIGH regime
        
        Args:
            enhanced (bool): Whether using enhanced ML (True) or basic ML (False)
            symbol (str, optional): Trading symbol for symbol-specific exceptions
            regime (str, optional): Trading regime ("LOW", "MID", "HIGH")
            
        Returns:
            float: Effective confidence threshold
        """
        # Base threshold: max(config.trading.min_confidence, 0.500)
        base_threshold = max(self.base_min_confidence, 0.500)
        
        # Safe mode adjustments - RELAXED: +0.05 by default, +0.20 only if critical flag
        if self.safe_mode:
            safe_trading = self.safe_mode_config.get('trading', {})
            safe_ml = self.safe_mode_config.get('ml', {})
            
            # Check if critical flag requires additional safety
            critical_flag = safe_ml.get('critical_mode', False) or safe_trading.get('critical_mode', False)
            
            if critical_flag:
                base_threshold += 0.20  # Only add +0.20 if critical flag is set
            else:
                base_threshold += 0.05  # Default safe mode adjustment: +0.05 (reduced from +0.20)
        
        # Enhanced ML vs Basic ML adjustments
        if enhanced:
            # Enhanced ML uses base threshold as-is
            effective_threshold = base_threshold
        else:
            # Basic ML: effective_threshold_basic = max(0.58, effective_threshold - 0.07)
            effective_threshold = max(0.58, base_threshold - 0.07)
        
        # ‚úÖ MEJORA 2: Conditional Threshold (HIGH regime + copytrading + dominance baja)
        if self.conditional_threshold_manager and regime == "HIGH":
            try:
                # Check if copytrading is enabled (simplified check)
                copytrading_enabled = self.copy_enabled
                
                # Get adjusted threshold
                adjusted_threshold, reason = self.conditional_threshold_manager.get_threshold(
                    regime, copytrading_enabled
                )
                
                # Only apply if lower than current threshold (more permissive)
                if adjusted_threshold < effective_threshold:
                    print(f"üéØ Conditional threshold: {effective_threshold:.3f} ‚Üí {adjusted_threshold:.3f} ({reason})")
                    effective_threshold = adjusted_threshold
            
            except Exception as e:
                print(f"‚ö†Ô∏è  Conditional threshold error: {e}")
        
        # Symbol-specific exceptions - ADJUSTED
        if symbol:
            symbol_base = symbol.split('/')[0]  # Extract base currency (e.g., 'BTC' from 'BTC/USDT')
            
            # High volatility symbols: +0.02 (reduced from +0.03)
            high_vol_symbols = self.config.get('symbol_specific', {}).get('high_volatility_symbols', [])
            if symbol_base in high_vol_symbols:
                effective_threshold += 0.02  # +2% for high volatility (reduced from 3%)
            
            # Stable symbols can use slightly lower thresholds
            stable_symbols = self.config.get('symbol_specific', {}).get('stable_symbols', [])
            if symbol_base in stable_symbols:
                effective_threshold -= 0.02  # -2% for stable symbols
        
        # Ensure threshold is within reasonable bounds - upper limit 0.9
        effective_threshold = max(0.50, min(0.90, effective_threshold))
        
        # ‚úÖ FIX #4: Clamp del effective_threshold con max_safe_threshold
        max_safe = self.config.get('ml', {}).get('max_safe_threshold', 0.80)
        effective_threshold = min(effective_threshold, max_safe)
        
        # Structured logging for threshold computation
        utc_now = get_utc_now()
        print(f"üîç ML_THRESHOLD: timestamp={utc_now.isoformat()}, symbol={symbol or 'none'}, "
              f"regime={regime or 'none'}, enhanced={enhanced}, safe_mode={self.safe_mode}, "
              f"base_threshold={base_threshold:.3f}, effective_threshold={effective_threshold:.3f}, "
              f"max_safe={max_safe:.3f}")
        
        return effective_threshold
    
    def compute_threshold_final(self, symbol, regime, safe_mode_active=None):
        """
        Calcular threshold final con TODOS los ajustes y clamp al final.
        Este m√©todo reemplaza el flujo anterior para tener un solo threshold final.
        
        Args:
            symbol: S√≠mbolo de trading
            regime: R√©gimen de volatilidad ('LOW', 'MID', 'HIGH')
            safe_mode_active: Si est√° en modo seguro (None = usar self.safe_mode)
            
        Returns:
            float: Threshold final clampado
        """
        if safe_mode_active is None:
            safe_mode_active = self.safe_mode
        
        # 1. Base threshold
        thr = max(self.base_min_confidence, 0.500)
        
        # 2. Safe mode adjustment
        if safe_mode_active:
            safe_ml = self.safe_mode_config.get('ml', {})
            safe_trading = self.safe_mode_config.get('trading', {})
            critical_flag = safe_ml.get('critical_mode', False) or safe_trading.get('critical_mode', False)
            
            if critical_flag:
                thr += 0.20  # Critical mode
            else:
                thr += 0.05  # Normal safe mode
        
        # 3. Symbol-specific adjustment
        if symbol:
            symbol_base = symbol.split('/')[0]
            high_vol_symbols = self.config.get('symbol_specific', {}).get('high_volatility_symbols', [])
            stable_symbols = self.config.get('symbol_specific', {}).get('stable_symbols', [])
            
            if symbol_base in high_vol_symbols:
                thr += 0.02  # +2% for high volatility
            elif symbol_base in stable_symbols:
                thr -= 0.02  # -2% for stable symbols
        
        # 4. Regime adjustment
        regime_adj = {
            'LOW': 0.08,   # +8% en baja volatilidad
            'MID': 0.10,   # +10% en volatilidad media
            'HIGH': 0.12   # +12% en alta volatilidad
        }.get(regime, 0.10)
        
        thr += regime_adj
        
        # 5. CLAMP FINAL (esto es cr√≠tico - aplicar DESPU√âS de todos los ajustes)
        max_safe = self.config.get('ml', {}).get('max_safe_threshold', 0.80)
        thr = min(max(thr, 0.50), max_safe)
        
        return thr
    
    async def daily_market_scanner(self):
        """Scan market for best trading opportunities considerando posiciones existentes"""
        print("\nüåÖ INICIANDO AN√ÅLISIS DIARIO DE MERCADO")
        print("=" * 50)
        
        # S√≠mbolos que ya tenemos en posiciones abiertas
        existing_symbols = set(self.positions.keys())
        
        if existing_symbols:
            print(f"üîí MANTENIENDO POSICIONES EXISTENTES: {', '.join(existing_symbols)}")
        
        try:
            if self.simulation_mode:
                # In simulation mode, use extended default list
                extended_symbols = [
                    'BTC/USDT', 'ETH/USDT', 'BNB/USDT', 'ADA/USDT', 'SOL/USDT',
                    'XRP/USDT', 'DOGE/USDT', 'MATIC/USDT', 'DOT/USDT', 'AVAX/USDT',
                    'LINK/USDT', 'UNI/USDT', 'LTC/USDT', 'ATOM/USDT', 'FTM/USDT',
                    'NEAR/USDT', 'ALGO/USDT', 'VET/USDT', 'ICP/USDT', 'SAND/USDT',
                    'MANA/USDT', 'CRV/USDT', 'AAVE/USDT', 'SUSHI/USDT', 'COMP/USDT'
                ]
                print("üéÆ Modo simulaci√≥n: Usando lista extendida de s√≠mbolos")
                return await self.analyze_symbol_list(extended_symbols)
            
            # Real mode: Scan actual market
            print("üìä Escaneando mercado real de Binance...")
            
            # Get all USDT pairs
            markets = self.exchange.load_markets()
            usdt_pairs = [symbol for symbol in markets.keys() 
                         if symbol.endswith('/USDT') and markets[symbol]['active']]
            
            print(f"üîç Encontrados {len(usdt_pairs)} pares USDT activos")
            
            # Get top pairs by volume (limit to top 100 for performance)
            top_pairs = await self.get_top_volume_pairs(usdt_pairs[:100])
            
            print(f"üìà Analizando top {len(top_pairs)} pares por volumen...")
            
            # Analyze and score pairs
            scored_pairs = await self.analyze_symbol_list(top_pairs)
            
            return scored_pairs
            
        except Exception as e:
            print(f"‚ùå Error en an√°lisis diario: {e}")
            print("üîÑ Usando s√≠mbolos por defecto")
            return self.default_symbols
    
    async def get_top_volume_pairs(self, pairs):
        """Get pairs sorted by 24h volume"""
        try:
            volume_data = []
            
            print("üìä Obteniendo datos de volumen...")
            
            # Get tickers for volume analysis
            tickers = self.exchange.fetch_tickers()
            
            for pair in pairs:
                if pair in tickers:
                    ticker = tickers[pair]
                    if ticker is not None:
                        volume_usdt = ticker.get('quoteVolume', 0)
                    else:
                        volume_usdt = 0
                    
                    # Filter by minimum volume
                    if volume_usdt >= self.min_volume_usdt:
                        volume_data.append((pair, volume_usdt))
            
            # Sort by volume and return top pairs
            volume_data.sort(key=lambda x: x[1], reverse=True)
            top_pairs = [pair[0] for pair in volume_data[:50]]  # Top 50 by volume
            
            print(f"‚úÖ Seleccionados {len(top_pairs)} pares con volumen > ${self.min_volume_usdt:,.0f}")
            
            return top_pairs
            
        except Exception as e:
            print(f"‚ùå Error obteniendo datos de volumen: {e}")
            return pairs[:20]  # Fallback to first 20
    
    async def analyze_symbol_list(self, symbol_list):
        """Analyze list of symbols and return best ones using deterministic scoring"""
        try:
            print(f"üî¨ Analizando {len(symbol_list)} s√≠mbolos...")
            
            # ============================================================================
            # DETERMINISTIC SYMBOL SELECTION (New System)
            # ============================================================================
            if SYMBOL_SCORING_AVAILABLE and self.symbol_memory and self.scanner_config:
                try:
                    print("üéØ Usando sistema de scoring determinista...")
                    
                    # Prepare candidates data
                    candidates = {}
                    klines_data = {}
                    
                    for i, symbol in enumerate(symbol_list):
                        try:
                            if i % 10 == 0:
                                print(f"   Recopilando datos: {i}/{len(symbol_list)}...")
                            
                            # Get ticker data
                            ticker = self.exchange.fetch_ticker(symbol)
                            
                            # Get OHLCV for technical indicators
                            ohlcv = self.exchange.fetch_ohlcv(symbol, '1h', limit=100)
                            
                            # Calculate spread
                            bid = ticker.get('bid', 0)
                            ask = ticker.get('ask', 0)
                            mid = (bid + ask) / 2 if bid and ask else ticker.get('last', 0)
                            spread_bps = ((ask - bid) / mid * 10000) if mid > 0 else 999
                            
                            # Calculate technical indicators (simplified)
                            closes = [float(k[4]) for k in ohlcv]
                            if len(closes) >= 50:
                                ema50 = np.mean(closes[-50:])
                                ema200 = np.mean(closes) if len(closes) >= 200 else ema50
                            else:
                                ema50 = ema200 = closes[-1] if closes else 0
                            
                            # Simple ADX approximation (using volatility)
                            if len(closes) >= 14:
                                volatility = np.std(closes[-14:]) / np.mean(closes[-14:])
                                adx14 = min(50, volatility * 1000)  # Rough approximation
                            else:
                                adx14 = 20
                            
                            # ATR percentage
                            if len(ohlcv) >= 14:
                                highs = [float(k[2]) for k in ohlcv[-14:]]
                                lows = [float(k[3]) for k in ohlcv[-14:]]
                                atr = np.mean([h - l for h, l in zip(highs, lows)])
                                atr_pct = (atr / closes[-1] * 100) if closes[-1] > 0 else 1.5
                            else:
                                atr_pct = 1.5
                            
                            candidates[symbol] = {
                                'volume_24h': ticker.get('quoteVolume', 0),
                                'spread_bps': spread_bps,
                                'price': ticker.get('last', 0),
                                'ema50': ema50,
                                'ema200': ema200,
                                'adx14': adx14,
                                'atr_pct': atr_pct
                            }
                            
                            klines_data[symbol] = ohlcv
                            
                            await asyncio.sleep(0.05)  # Rate limit
                            
                        except Exception as e:
                            print(f"‚ö†Ô∏è  Error recopilando datos de {symbol}: {e}")
                            continue
                    
                    # Get outcomes data from memory
                    outcomes_data = self.symbol_memory.get_all_metrics()
                    
                    # Detect current regime
                    regime = self.get_current_regime()
                    
                    # Select symbols deterministically
                    selected = select_symbols_deterministic(
                        candidates=candidates,
                        klines_data=klines_data,
                        outcomes_data=outcomes_data,
                        regime=regime,
                        config=self.scanner_config,
                        symbol_themes=self.symbol_themes
                    )
                    
                    print(f"\nüéØ SCORING DETERMINISTA: {len(selected)} s√≠mbolos seleccionados")
                    print(f"   Candidatos evaluados: {len(candidates)}")
                    print(f"   R√©gimen actual: {regime}")
                    
                    # Build scored_symbols for compatibility
                    scored_symbols = []
                    for symbol in selected:
                        score = await self.calculate_daily_score(symbol)
                        scored_symbols.append({
                            'symbol': symbol,
                            'score': score,
                            'timestamp': datetime.now().isoformat()
                        })
                    
                    top_symbols = scored_symbols
                    
                except Exception as e:
                    print(f"‚ö†Ô∏è  Error en scoring determinista: {e}")
                    print("   Fallback a sistema tradicional...")
                    # Set flag to use traditional system
                    use_traditional = True
                else:
                    use_traditional = False
            else:
                use_traditional = True
            
            # ============================================================================
            # TRADITIONAL SYSTEM (Fallback)
            # ============================================================================
            if use_traditional:
                scored_symbols = []
                
                for i, symbol in enumerate(symbol_list):
                    try:
                        if i % 10 == 0:
                            print(f"   Progreso: {i}/{len(symbol_list)} s√≠mbolos analizados...")
                        
                        score = await self.calculate_daily_score(symbol)
                        
                        if score > 0.3:  # Minimum threshold
                            scored_symbols.append({
                                'symbol': symbol,
                                'score': score,
                                'timestamp': datetime.now().isoformat()
                            })
                        
                        # Small delay to avoid rate limits
                        await asyncio.sleep(0.1)
                        
                    except Exception as e:
                        print(f"‚ö†Ô∏è  Error analizando {symbol}: {e}")
                        continue
                
                # Sort by score and select top symbols
                scored_symbols.sort(key=lambda x: x['score'], reverse=True)
                
                # Apply Symbol Bandits for intelligent selection
                if RISK_MANAGEMENT_AVAILABLE:
                    try:
                        candidates = [s['symbol'] for s in scored_symbols]
                        selected_symbols = bandit.select_symbols(candidates, max_select=self.max_daily_symbols)
                        # Rebuild scored_symbols with bandit selection
                        top_symbols = [s for s in scored_symbols if s['symbol'] in selected_symbols]
                        print(f"üé∞ Symbol Bandits: Selected {len(top_symbols)} from {len(candidates)} candidates")
                    except Exception as e:
                        print(f"‚ö†Ô∏è  Symbol Bandits error: {e}, using top scores")
                        top_symbols = scored_symbols[:self.max_daily_symbols]
                else:
                    top_symbols = scored_symbols[:self.max_daily_symbols]
            
            print(f"\nüéØ TOP {len(top_symbols)} S√çMBOLOS SELECCIONADOS:")
            for i, sym_data in enumerate(top_symbols, 1):
                print(f"   {i:2d}. {sym_data['symbol']:12s} - Score: {sym_data['score']:.3f}")
            
            # Combinar s√≠mbolos existentes + nuevos candidatos
            existing_symbols = set(self.positions.keys())
            new_candidates = [sym_data['symbol'] for sym_data in top_symbols]
            
            # Filtrar candidatos que no est√©n en posiciones existentes
            available_slots = self.max_daily_symbols - len(existing_symbols)
            
            if available_slots > 0:
                # Filtrar s√≠mbolos que ya tenemos
                filtered_candidates = [sym for sym in new_candidates if sym not in existing_symbols]
                new_symbols = filtered_candidates[:available_slots]
                
                if new_symbols:
                    print(f"üÜï AGREGANDO {len(new_symbols)} NUEVOS S√çMBOLOS: {', '.join(new_symbols)}")
                else:
                    print("‚ÑπÔ∏è No hay nuevos s√≠mbolos candidatos disponibles")
            else:
                new_symbols = []
                print("‚ö†Ô∏è M√ÅXIMO DE S√çMBOLOS ALCANZADO, manteniendo solo posiciones existentes")
            
            # Combinar s√≠mbolos existentes + nuevos
            final_symbols = list(existing_symbols) + new_symbols
            
            print(f"\nüìä S√çMBOLOS FINALES ({len(final_symbols)}):")
            for i, symbol in enumerate(final_symbols, 1):
                status = "üîí EXISTENTE" if symbol in existing_symbols else "üÜï NUEVO"
                print(f"   {i:2d}. {symbol:12s} - {status}")
            
            # Save analysis results
            if self.trade_db:
                await self.save_daily_analysis(top_symbols)
            
            return final_symbols
            
        except Exception as e:
            print(f"‚ùå Error en analyze_symbol_list: {e}")
            return self.default_symbols
    
    def get_current_regime(self) -> str:
        """
        Detect current market regime based on BTC volatility
        
        Returns:
            'LOW', 'MID', or 'HIGH'
        """
        try:
            # Get BTC recent data
            if not self.simulation_mode and hasattr(self, 'exchange'):
                ohlcv = self.exchange.fetch_ohlcv('BTC/USDT', '1h', limit=24)
                closes = [float(k[4]) for k in ohlcv]
                
                # Calculate volatility (std dev of returns)
                returns = [closes[i]/closes[i-1] - 1 for i in range(1, len(closes))]
                volatility = np.std(returns) * 100  # As percentage
                
                # Classify regime
                if volatility < 1.5:
                    return 'LOW'
                elif volatility < 3.0:
                    return 'MID'
                else:
                    return 'HIGH'
            else:
                # Default for simulation
                return 'MID'
        
        except Exception as e:
            print(f"‚ö†Ô∏è  Error detecting regime: {e}")
            return 'MID'
    
    async def update_symbol_memory_on_close(self, symbol: str, outcome: Dict):
        """Update symbol memory when closing a position"""
        if SYMBOL_SCORING_AVAILABLE and self.symbol_memory:
            try:
                self.symbol_memory.add_outcome(symbol, outcome)
                
                # Check if should cooldown
                if self.symbol_memory.should_cooldown(symbol):
                    self.symbol_memory.set_cooldown(symbol, duration_days=7)
                    print(f"üö´ {symbol}: Cooldown activated (poor performance)")
            
            except Exception as e:
                print(f"‚ö†Ô∏è  Error updating symbol memory: {e}")
    
    async def update_market_conditions_for_threshold(self):
        """
        Update market conditions for conditional threshold manager.
        
        ‚úÖ MEJORA 2: Actualiza dominancia BTC y momentum de alts
        """
        try:
            if not self.conditional_threshold_manager:
                return
            
            # Get BTC and ETH price changes (24h)
            if self.simulation_mode:
                # Simulate market conditions
                btc_change_24h = random.uniform(-5.0, 5.0)
                eth_change_24h = random.uniform(-5.0, 5.0)
            else:
                try:
                    btc_ticker = self.exchange.fetch_ticker('BTC/USDT')
                    eth_ticker = self.exchange.fetch_ticker('ETH/USDT')
                    
                    btc_change_24h = btc_ticker.get('percentage', 0.0)
                    eth_change_24h = eth_ticker.get('percentage', 0.0)
                except Exception as e:
                    print(f"‚ö†Ô∏è  Error fetching market data: {e}")
                    return
            
            # Estimate BTC dominance
            from signals.conditional_threshold import get_btc_dominance_estimate
            btc_dominance = get_btc_dominance_estimate(btc_change_24h, eth_change_24h)
            
            # Calculate alt momentum (simplified)
            alt_momentum = 0.5 + (eth_change_24h - btc_change_24h) / 20.0
            alt_momentum = max(0.0, min(1.0, alt_momentum))
            
            # Update manager
            self.conditional_threshold_manager.update_market_conditions(btc_dominance, alt_momentum)
            
            print(f"üìä Market conditions updated: BTC_dom={btc_dominance:.1f}%, alt_momentum={alt_momentum:.2f}")
        
        except Exception as e:
            print(f"‚ö†Ô∏è  Error in update_market_conditions_for_threshold: {e}")
    
    def can_trade_symbol_now(self, symbol: str) -> bool:
        """
        Check if symbol can be traded now (cooldown + daily limit).
        
        ‚úÖ MEJORA 3: Whitelist de s√≠mbolos calientes
        - S√≠mbolos con win reciente + PF>1 + volatilidad sana ‚Üí 5 trades/d√≠a
        - S√≠mbolos normales ‚Üí 3 trades/d√≠a
        """
        if SYMBOL_SCORING_AVAILABLE and self.symbol_memory:
            try:
                max_per_day = self.scanner_config.get('cap_trades_per_symbol_per_day', 3)
                hot_symbol_max = 5  # Hot symbols get higher limit
                
                # Use whitelist logic
                can_trade, reason = self.symbol_memory.can_trade_symbol_with_whitelist(
                    symbol, max_per_day, hot_symbol_max
                )
                
                if not can_trade:
                    print(f"‚è≠Ô∏è  {symbol}: Cannot trade - {reason}")
                else:
                    # Log if hot symbol
                    if "hot_symbol" in reason:
                        print(f"üî• {symbol}: Hot symbol - {reason}")
                
                return can_trade
            
            except Exception as e:
                print(f"‚ö†Ô∏è  Error checking symbol tradability: {e}")
                return True
        return True
    
    async def store_enhanced_analysis(self, symbol: str, analysis: dict) -> None:
        """Almacena an√°lisis Enhanced ML en la base de datos"""
        from datetime import datetime
        
        print(f"üîç ML_TRACE: storage_write_started, symbol={symbol}, "
              f"enhanced_storage_available={ENHANCED_STORAGE_AVAILABLE}, "
              f"storage_initialized={self.enhanced_storage is not None}")
        
        if not self.enhanced_storage:
            reason = "storage_not_initialized" if ENHANCED_STORAGE_AVAILABLE else "import_error"
            print(f"üîç ML_TRACE: storage_write=fail, reason={reason}, ml_storage=off")
            return
        
        try:
            # Obtener datos Enhanced ML si est√°n disponibles
            enhanced_data = {}
            
            if ENHANCED_ML_AVAILABLE:
                try:
                    from offline_enhanced_ml import get_offline_analysis_breakdown
                    
                    # Obtener an√°lisis completo
                    breakdown = get_offline_analysis_breakdown(
                        symbol, 
                        analysis.get('amount', 100.0),
                        analysis.get('price', 0.0),
                        analysis.get('confidence', 0.0)
                    )
                    
                    enhanced_data = {
                        'base_confidence': breakdown.get('base_confidence', 0.0),
                        'enhanced_confidence': breakdown.get('enhanced_confidence', 0.0),
                        'copy_trading_score': breakdown.get('copy_trading_score', 0.0),
                        'market_score': breakdown.get('market_score', 0.0),
                        'sentiment_score': breakdown.get('sentiment_score', 0.0),
                        'external_data': {
                            'fear_greed': {'value': 50},
                            'funding_rates': {'current_funding_rate': 0.0}
                        }
                    }
                    
                    print(f"üîç ML_TRACE: enhanced_data_extracted, copy_score={enhanced_data['copy_trading_score']:.3f}, "
                          f"sentiment_score={enhanced_data['sentiment_score']:.3f}, "
                          f"market_score={enhanced_data['market_score']:.3f}")
                    
                except Exception as e:
                    print(f"üîç ML_TRACE: enhanced_data_extraction_error='{str(e)}', using_fallback=True")
            
            # Almacenar en base de datos
            success = self.enhanced_storage.store_enhanced_analysis(symbol, enhanced_data)
            
            if success:
                print(f"üîç ML_TRACE: storage_write=success, symbol={symbol}")
            else:
                print(f"üîç ML_TRACE: storage_write=fail, reason=database_error, symbol={symbol}")
            
        except Exception as e:
            print(f"üîç ML_TRACE: storage_write=fail, reason=exception, error='{str(e)}', symbol={symbol}")
    async def calculate_daily_score(self, symbol):
        """Calculate comprehensive daily score for a symbol with advanced analysis"""
        try:
            if self.simulation_mode:
                # Simulaci√≥n usa ML real para validaci√≥n
                print(f"üéÆ Modo simulaci√≥n: usando ML real para {symbol}")
                # Contin√∫a con flujo ML normal (enhanced ‚Üí basic)
            
            # Real advanced scoring
            ticker = self.exchange.fetch_ticker(symbol)
            
            # Update market data timestamp
            if self.market_enabled:
                self.last_data_timestamps['market'] = get_utc_now()
            
            # 1. Volume Score (25% weight) - Reduced from 40%
            volume_score = self.calculate_volume_score(ticker)
            
            # 2. Momentum Score (20% weight) - Reduced from 30%
            momentum_score = self.calculate_momentum_score(ticker)
            
            # 3. Advanced Technical Score (25% weight) - Increased from 20%
            technical_score = await self.calculate_advanced_technical_score(symbol)
            
            # 4. Sentiment Score (15% weight) - NEW
            sentiment_score = await self.calculate_sentiment_score(symbol)
            
            # 5. Fundamental Score (10% weight) - NEW
            fundamental_score = await self.calculate_fundamental_score(symbol)
            
            # 6. Stability Score (5% weight) - Reduced from 10%
            stability_score = self.calculate_stability_score(ticker)
            
            # Weighted final score with advanced factors
            final_score = (
                volume_score * 0.25 +
                momentum_score * 0.20 +
                technical_score * 0.25 +
                sentiment_score * 0.15 +
                fundamental_score * 0.10 +
                stability_score * 0.05
            )
            
            # TRADING 24/7: Eliminada penalizaci√≥n horaria
            # Los datos hist√≥ricos muestran que horarios 2-7 UTC ten√≠an buen rendimiento
            # Horario asi√°tico (2-7 UTC) ahora optimizado para capturar oportunidades globales
            current_hour = get_utc_now().hour
            
            # Control de staleness de datos
            penalized_score, staleness_reason = self.apply_staleness_penalty(final_score, symbol)
            
            # If hard limit triggered, return 0.0
            if staleness_reason == BypassReason.STALE_DATA_HARD_LIMIT:
                return 0.0
            
            final_score = penalized_score
            
            return min(final_score, 1.0)
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Error calculando score avanzado para {symbol}: {e}")
            return 0.0
    

    
    def calculate_volume_score(self, ticker):
        """Calculate volume-based score"""
        try:
            if ticker is None:
                return 0.0
            volume_usdt = ticker.get('quoteVolume', 0)
            
            # Normalize volume (1M = 0.5, 10M = 1.0)
            if volume_usdt < self.min_volume_usdt:
                return 0.0
            
            # Logarithmic scaling for volume
            volume_score = min(np.log10(volume_usdt / self.min_volume_usdt) / 2, 1.0)
            
            return volume_score
            
        except Exception:
            return 0.0
    
    def calculate_momentum_score(self, ticker):
        """Calculate momentum-based score"""
        try:
            if ticker is None:
                return 0.0
            price_change_24h = ticker.get('percentage', 0)
            
            # Optimal momentum range: -5% to +15%
            if -5 <= price_change_24h <= 15:
                # Positive momentum gets higher score
                if price_change_24h > 0:
                    momentum_score = 0.5 + (price_change_24h / 30)  # 0.5 to 1.0
                else:
                    momentum_score = 0.5 + (price_change_24h / 10)  # 0.0 to 0.5
            else:
                # Extreme movements get lower scores
                momentum_score = 0.2
            
            return max(0.0, min(momentum_score, 1.0))
            
        except Exception:
            return 0.0
    
    async def calculate_advanced_technical_score(self, symbol):
        """Calculate advanced technical analysis score with patterns and indicators"""
        try:
            # Get recent OHLCV data
            ohlcv = self.exchange.fetch_ohlcv(symbol, '1h', limit=100)
            
            if len(ohlcv) < 50:
                return 0.5  # Neutral if not enough data
            
            # Extract OHLCV arrays
            opens = np.array([candle[1] for candle in ohlcv])
            highs = np.array([candle[2] for candle in ohlcv])
            lows = np.array([candle[3] for candle in ohlcv])
            closes = np.array([candle[4] for candle in ohlcv])
            volumes = np.array([candle[5] for candle in ohlcv])
            
            # 1. Enhanced RSI analysis
            rsi = self.calculate_simple_rsi(closes)
            rsi_score = self.get_rsi_score(rsi)
            
            # 2. MACD analysis
            macd_score = self.calculate_macd_score(closes)
            
            # 3. Bollinger Bands analysis
            bb_score = self.calculate_bollinger_score(closes)
            
            # 4. Candlestick patterns
            pattern_score = self.detect_candlestick_patterns(opens, highs, lows, closes)
            
            # 5. Support/Resistance levels
            sr_score = self.calculate_support_resistance_score(highs, lows, closes)
            
            # 6. Volume analysis
            volume_score = self.calculate_volume_analysis_score(volumes, closes)
            
            # 7. Trend strength
            trend_score = self.calculate_trend_strength(closes)
            
            # Combine all technical factors
            technical_score = (
                rsi_score * 0.20 +
                macd_score * 0.15 +
                bb_score * 0.15 +
                pattern_score * 0.15 +
                sr_score * 0.10 +
                volume_score * 0.15 +
                trend_score * 0.10
            )
            
            return max(0.0, min(technical_score, 1.0))
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Error en an√°lisis t√©cnico avanzado: {e}")
            return 0.5
    
    async def calculate_sentiment_score(self, symbol):
        """Calculate market sentiment score from multiple sources"""
        try:
            if not self.use_sentiment_analysis:
                return 0.5  # Neutral if disabled
            
            # Check cache first
            cache_key = f"sentiment_{symbol}"
            if cache_key in self.sentiment_cache:
                cache_time, cached_score = self.sentiment_cache[cache_key]
                if (datetime.now() - cache_time).total_seconds() < self.cache_duration:
                    return cached_score
            
            sentiment_scores = []
            
            # 1. Fear & Greed Index (general market sentiment)
            try:
                fg_score = await self.get_fear_greed_index()
                sentiment_scores.append(fg_score)
            except Exception as e:
                pass
            
            # 2. CoinGecko sentiment (if available)
            try:
                cg_score = await self.get_coingecko_sentiment(symbol)
                if cg_score is not None:
                    sentiment_scores.append(cg_score)
                    # Update sentiment data timestamp
                    if self.sentiment_enabled:
                        self.last_data_timestamps['sentiment'] = get_utc_now()
            except:
                pass
            
            # 3. Price momentum sentiment
            try:
                momentum_sentiment = await self.get_momentum_sentiment(symbol)
                sentiment_scores.append(momentum_sentiment)
            except:
                pass
            
            # Calculate average sentiment
            if sentiment_scores:
                final_sentiment = np.mean(sentiment_scores)
            else:
                final_sentiment = 0.5  # Neutral if no data
            
            # Cache the result
            self.sentiment_cache[cache_key] = (datetime.now(), final_sentiment)
            
            return max(0.0, min(final_sentiment, 1.0))
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Error en an√°lisis de sentimiento: {e}")
            return 0.5
    
    async def calculate_fundamental_score(self, symbol):
        """Calculate fundamental analysis score"""
        try:
            if not self.use_fundamental_analysis:
                return 0.5  # Neutral if disabled
            
            # Check cache first
            cache_key = f"fundamental_{symbol}"
            if cache_key in self.fundamental_cache:
                cache_time, cached_score = self.fundamental_cache[cache_key]
                if (datetime.now() - cache_time).total_seconds() < self.cache_duration:
                    return cached_score
            
            fundamental_scores = []
            
            # 1. Market cap momentum
            try:
                mc_score = await self.get_market_cap_momentum(symbol)
                if mc_score is not None:
                    fundamental_scores.append(mc_score)
            except:
                pass
            
            # 2. Volume profile analysis
            try:
                vol_profile_score = await self.get_volume_profile_score(symbol)
                fundamental_scores.append(vol_profile_score)
            except:
                pass
            
            # 3. Relative strength vs market
            try:
                rs_score = await self.get_relative_strength_score(symbol)
                fundamental_scores.append(rs_score)
            except:
                pass
            
            # Calculate average fundamental score
            if fundamental_scores:
                final_fundamental = np.mean(fundamental_scores)
            else:
                final_fundamental = 0.5  # Neutral if no data
            
            # Cache the result
            self.fundamental_cache[cache_key] = (datetime.now(), final_fundamental)
            
            return max(0.0, min(final_fundamental, 1.0))
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Error en an√°lisis fundamental: {e}")
            return 0.5
    
    def calculate_simple_rsi(self, prices, period=14):
        """Calculate simple RSI"""
        try:
            if len(prices) < period + 1:
                return 50.0  # Neutral RSI
            
            deltas = np.diff(prices)
            gains = np.where(deltas > 0, deltas, 0)
            losses = np.where(deltas < 0, -deltas, 0)
            
            avg_gain = np.mean(gains[-period:])
            avg_loss = np.mean(losses[-period:])
            
            if avg_loss == 0:
                return 100.0
            
            rs = avg_gain / avg_loss
            rsi = 100 - (100 / (1 + rs))
            
            return rsi
            
        except Exception:
            return 50.0
    
    def get_rsi_score(self, rsi):
        """Convert RSI to score (0-1)"""
        if 40 <= rsi <= 60:
            return 0.9  # Optimal range
        elif 30 <= rsi <= 70:
            return 0.7  # Good range
        elif 20 <= rsi <= 80:
            return 0.4  # Acceptable range
        else:
            return 0.2  # Extreme values
    
    def calculate_macd_score(self, closes):
        """Calculate MACD-based score"""
        try:
            if len(closes) < 26:
                return 0.5
            
            # Simple MACD calculation
            ema12 = self.calculate_ema(closes, 12)
            ema26 = self.calculate_ema(closes, 26)
            macd_line = ema12[-1] - ema26[-1]
            
            # MACD signal (9-period EMA of MACD)
            macd_history = ema12[-9:] - ema26[-9:]
            macd_signal = np.mean(macd_history)
            
            # Score based on MACD position
            if macd_line > macd_signal and macd_line > 0:
                return self.config.get('ml', {}).get('macd_bullish_score', 0.75)  # Bullish with default
            elif macd_line > macd_signal:
                return 0.6  # Improving
            elif macd_line < 0:
                return 0.3  # Bearish
            else:
                return 0.5  # Neutral
                
        except Exception:
            return 0.5
    
    def calculate_ema(self, prices, period):
        """Calculate Exponential Moving Average"""
        try:
            prices = np.array(prices, dtype=float)  # Forzar dtype=float
            ema = np.zeros_like(prices, dtype=float)
            ema[0] = prices[0]
            multiplier = 2 / (period + 1)
            
            for i in range(1, len(prices)):
                ema[i] = (prices[i] * multiplier) + (ema[i-1] * (1 - multiplier))
            
            return ema
        except Exception:
            return np.array(prices, dtype=float)
    
    def calculate_bollinger_score(self, closes):
        """Calculate Bollinger Bands score"""
        try:
            if len(closes) < 20:
                return 0.5
            
            # 20-period moving average
            sma = np.mean(closes[-20:])
            
            # Standard deviation
            std = np.std(closes[-20:])
            
            # Bollinger Bands
            upper_band = sma + (2 * std)
            lower_band = sma - (2 * std)
            
            current_price = closes[-1]
            
            # Position within bands
            if lower_band <= current_price <= upper_band:
                # Normal range - calculate position
                band_position = (current_price - lower_band) / (upper_band - lower_band)
                if 0.3 <= band_position <= 0.7:
                    return self.config.get('ml', {}).get('bollinger_good_position_score', 0.8)  # Good position
                else:
                    return 0.6  # Acceptable
            elif current_price < lower_band:
                return 0.9  # Oversold - potential buy
            else:
                return 0.2  # Overbought - avoid
                
        except Exception:
            return 0.5
    
    def detect_candlestick_patterns(self, opens, highs, lows, closes):
        """Detect bullish candlestick patterns"""
        try:
            if len(closes) < 3:
                return 0.5
            
            pattern_score = 0.5
            recent_candles = 3
            
            for i in range(-recent_candles, 0):
                o, h, l, c = opens[i], highs[i], lows[i], closes[i]
                body = abs(c - o)
                upper_shadow = h - max(o, c)
                lower_shadow = min(o, c) - l
                
                # Doji pattern (indecision)
                if body < (h - l) * 0.1:
                    pattern_score += 0.05
                
                # Hammer pattern (bullish reversal)
                if (lower_shadow > body * 2 and upper_shadow < body * 0.5 and c > o):
                    pattern_score += 0.15
                
                # Bullish engulfing
                if i > -recent_candles and c > o and closes[i-1] < opens[i-1]:
                    if c > opens[i-1] and o < closes[i-1]:
                        pattern_score += 0.2
            
            return min(pattern_score, 1.0)
            
        except Exception:
            return 0.5
    
    def calculate_support_resistance_score(self, highs, lows, closes):
        """Calculate support/resistance score"""
        try:
            if len(closes) < 20:
                return 0.5
            
            current_price = closes[-1]
            recent_highs = highs[-20:]
            recent_lows = lows[-20:]
            
            # Find potential resistance (recent highs)
            resistance_levels = []
            for i in range(1, len(recent_highs)-1):
                if recent_highs[i] > recent_highs[i-1] and recent_highs[i] > recent_highs[i+1]:
                    resistance_levels.append(recent_highs[i])
            
            # Find potential support (recent lows)
            support_levels = []
            for i in range(1, len(recent_lows)-1):
                if recent_lows[i] < recent_lows[i-1] and recent_lows[i] < recent_lows[i+1]:
                    support_levels.append(recent_lows[i])
            
            # Score based on position relative to S/R
            score = 0.5
            
            if support_levels:
                nearest_support = max([s for s in support_levels if s < current_price], default=0)
                if nearest_support > 0:
                    support_distance = (current_price - nearest_support) / current_price
                    if support_distance < 0.02:  # Within 2% of support
                        score += 0.2
            
            if resistance_levels:
                nearest_resistance = min([r for r in resistance_levels if r > current_price], default=float('inf'))
                if nearest_resistance != float('inf'):
                    resistance_distance = (nearest_resistance - current_price) / current_price
                    if resistance_distance > 0.05:  # Good distance from resistance
                        score += 0.2
            
            return min(score, 1.0)
            
        except Exception:
            return 0.5
    
    def calculate_volume_analysis_score(self, volumes, closes):
        """Advanced volume analysis"""
        try:
            if len(volumes) < 10:
                return 0.5
            
            # Volume trend
            recent_volume = np.mean(volumes[-5:])
            avg_volume = np.mean(volumes[-20:-5])
            volume_ratio = recent_volume / avg_volume if avg_volume > 0 else 1.0
            
            # Price-volume relationship
            price_changes = np.diff(closes[-10:])
            volume_changes = np.diff(volumes[-10:])
            
            # Positive correlation between price and volume is good
            correlation = np.corrcoef(price_changes, volume_changes)[0, 1] if len(price_changes) > 1 else 0
            
            # Volume score
            volume_score = 0.5
            
            if volume_ratio > 1.5:  # High volume
                volume_score += 0.3
            elif volume_ratio > 1.2:
                volume_score += 0.1
            
            if correlation > 0.3:  # Good price-volume correlation
                volume_score += 0.2
            
            return min(volume_score, 1.0)
            
        except Exception:
            return 0.5
    
    def calculate_trend_strength(self, closes):
        """Calculate trend strength score"""
        try:
            if len(closes) < 20:
                return 0.5
            
            # Multiple timeframe trend analysis
            short_trend = closes[-5:].mean() / closes[-10:-5].mean() - 1
            medium_trend = closes[-10:].mean() / closes[-20:-10].mean() - 1
            
            # Trend consistency
            if short_trend > 0 and medium_trend > 0:
                # Both trends positive
                trend_score = 0.7 + min(abs(short_trend) * 10, 0.3)
            elif short_trend < 0 and medium_trend < 0:
                # Both trends negative
                trend_score = 0.3 - min(abs(short_trend) * 10, 0.3)
            else:
                # Mixed trends
                trend_score = 0.5
            
            return max(0.0, min(trend_score, 1.0))
            
        except Exception:
            return 0.5
    
    def calculate_stability_score(self, ticker):
        """Calculate stability/reliability score"""
        try:
            if ticker is None:
                return 0.5
            # Bid-ask spread as stability indicator
            bid = ticker.get('bid', 0)
            ask = ticker.get('ask', 0)
            
            if bid > 0 and ask > 0:
                spread_pct = ((ask - bid) / bid) * 100
                # Lower spread = higher stability
                stability_score = max(0.0, 1.0 - (spread_pct / 2))
            else:
                stability_score = 0.5
            
            return stability_score
            
        except Exception:
            return 0.5
    
    async def calculate_advanced_market_score(self, symbol):
        """
        Calcular score avanzado considerando ETF flows y valoraci√≥n BTC
        
        Zonas de valoraci√≥n BTC:
        - Oportunidad: < 0.45 (compra agresiva)
        - DCA: 0.45-1.2 (compra gradual)  
        - Riesgo: > 1.2 (precauci√≥n)
        """
        try:
            # Score base tradicional
            base_score = random.uniform(0.4, 0.95)
            
            # 1. AN√ÅLISIS DE FLUJO NETO ETF
            etf_flow_score = await self.calculate_etf_flow_score()
            
            # 2. AN√ÅLISIS DE VALORACI√ìN BTC
            btc_valuation_score = await self.calculate_btc_valuation_score()
            
            # 3. AN√ÅLISIS DE CORRELACI√ìN CON BTC (para altcoins)
            btc_correlation_score = await self.calculate_btc_correlation_score(symbol)
            
            # 4. AN√ÅLISIS DE DOMINANCIA BTC
            btc_dominance_score = await self.calculate_btc_dominance_score()
            
            # Pesos para el score final
            weights = {
                'base': 0.40,           # 40% score tradicional
                'etf_flow': 0.25,       # 25% flujo ETF
                'btc_valuation': 0.20,  # 20% valoraci√≥n BTC
                'btc_correlation': 0.10, # 10% correlaci√≥n BTC
                'btc_dominance': 0.05   # 5% dominancia BTC
            }
            
            # Calcular score ponderado
            advanced_score = (
                base_score * weights['base'] +
                etf_flow_score * weights['etf_flow'] +
                btc_valuation_score * weights['btc_valuation'] +
                btc_correlation_score * weights['btc_correlation'] +
                btc_dominance_score * weights['btc_dominance']
            )
            
            # Log detallado para monitoreo (solo si VERBOSE_SCORING est√° activo)
            if VERBOSE_SCORING:
                print(f"üßÆ {symbol} Advanced Score Breakdown:")
                print(f"   üìä Base: {base_score:.3f} ({weights['base']:.0%})")
                print(f"   üí∞ ETF Flow: {etf_flow_score:.3f} ({weights['etf_flow']:.0%})")
                print(f"   ‚Çø BTC Valuation: {btc_valuation_score:.3f} ({weights['btc_valuation']:.0%})")
                print(f"   üîó BTC Correlation: {btc_correlation_score:.3f} ({weights['btc_correlation']:.0%})")
                print(f"   üëë BTC Dominance: {btc_dominance_score:.3f} ({weights['btc_dominance']:.0%})")
                print(f"   üéØ Final Score: {advanced_score:.3f}")
            
            return min(advanced_score, 1.0)
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error calculando advanced market score: {e}")
            return random.uniform(0.4, 0.95)  # Fallback al score tradicional
    
    async def calculate_etf_flow_score(self):
        """
        Calcular score basado en flujo neto de ETFs de Bitcoin
        
        Flujo positivo = bullish (score alto)
        Flujo negativo = bearish (score bajo)
        """
        try:
            # Simular datos de ETF flow (en producci√≥n, obtener de API real)
            # Valores t√≠picos: -500M a +500M USD diarios
            
            # Para demo, usar datos simulados basados en tendencias reales
            import random
            from datetime import datetime
            
            # Simular flujo basado en hora (Asia m√°s conservadora, Am√©rica m√°s agresiva)
            current_hour = datetime.now().hour
            
            if 0 <= current_hour < 8:  # Asia-Pac√≠fico
                # Flujo m√°s conservador en Asia
                etf_flow_millions = random.uniform(-100, 200)
            elif 8 <= current_hour < 16:  # Europa
                # Flujo moderado en Europa
                etf_flow_millions = random.uniform(-150, 250)
            else:  # Am√©rica
                # Flujo m√°s agresivo en Am√©rica
                etf_flow_millions = random.uniform(-200, 400)
            
            # Convertir flujo a score (0.0 - 1.0)
            if etf_flow_millions >= 200:
                score = 0.9  # Flujo muy positivo
            elif etf_flow_millions >= 100:
                score = 0.8  # Flujo positivo
            elif etf_flow_millions >= 50:
                score = 0.7  # Flujo ligeramente positivo
            elif etf_flow_millions >= -50:
                score = 0.6  # Flujo neutral
            elif etf_flow_millions >= -100:
                score = 0.4  # Flujo ligeramente negativo
            elif etf_flow_millions >= -200:
                score = 0.3  # Flujo negativo
            else:
                score = 0.2  # Flujo muy negativo
            
            if VERBOSE_MARKET_CONTEXT:
                print(f"üí∞ ETF Flow: ${etf_flow_millions:.0f}M ‚Üí Score: {score:.3f}")
            return score
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error calculando ETF flow score: {e}")
            return 0.6  # Score neutral por defecto
    
    async def calculate_btc_valuation_score(self):
        """
        Calcular score basado en valoraci√≥n de BTC
        
        Zonas:
        - < 0.45: Zona de oportunidad (score alto 0.8-1.0)
        - 0.45-1.2: Zona DCA (score medio 0.5-0.8)
        - > 1.2: Zona de riesgo (score bajo 0.2-0.5)
        """
        try:
            # Simular ratio de valoraci√≥n BTC (precio actual / precio "justo")
            # En producci√≥n, usar m√©tricas como:
            # - MVRV Ratio
            # - NVT Ratio  
            # - Stock-to-Flow
            # - Pi Cycle Top
            # - 200 Week MA Multiple
            
            import random
            
            # Simular ratio de valoraci√≥n (valores t√≠picos 0.2 - 2.0)
            valuation_ratio = random.uniform(0.3, 1.8)
            
            # Determinar zona y score
            if valuation_ratio < 0.45:
                # Zona de OPORTUNIDAD - Compra agresiva
                score = random.uniform(0.85, 1.0)
                zone = "üü¢ OPORTUNIDAD"
                strategy = "Compra agresiva"
            elif valuation_ratio <= 1.2:
                # Zona DCA - Compra gradual
                # Score inversamente proporcional dentro de la zona
                normalized_ratio = (valuation_ratio - 0.45) / (1.2 - 0.45)  # 0-1
                score = 0.8 - (normalized_ratio * 0.3)  # 0.8 a 0.5
                zone = "üü° DCA"
                strategy = "Compra gradual"
            else:
                # Zona de RIESGO - Precauci√≥n
                score = random.uniform(0.2, 0.5)
                zone = "üî¥ RIESGO"
                strategy = "Precauci√≥n/Venta"
            
            if VERBOSE_MARKET_CONTEXT:
                print(f"‚Çø BTC Valuation: {valuation_ratio:.3f} | {zone} | {strategy} ‚Üí Score: {score:.3f}")
            return score
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error calculando BTC valuation score: {e}")
            return 0.6  # Score neutral por defecto
    
    async def calculate_btc_correlation_score(self, symbol):
        """
        Calcular score basado en correlaci√≥n con BTC
        
        Alta correlaci√≥n + BTC bullish = score alto
        Baja correlaci√≥n = score independiente
        """
        try:
            # Correlaciones t√≠picas con BTC
            correlations = {
                'ETH/USDT': 0.85,
                'BNB/USDT': 0.75,
                'ADA/USDT': 0.80,
                'SOL/USDT': 0.82,
                'AVAX/USDT': 0.78,
                'DOT/USDT': 0.76,
                'MATIC/USDT': 0.73,
                'LINK/USDT': 0.71,
                'XRP/USDT': 0.65,  # Menor correlaci√≥n
                'DOGE/USDT': 0.70,
                'LTC/USDT': 0.88,
                'BTC/USDT': 1.0   # Perfecta correlaci√≥n consigo mismo
            }
            
            correlation = correlations.get(symbol, 0.75)  # Default 0.75
            
            # Simular tendencia BTC (en producci√≥n, usar precio real)
            btc_trend = random.uniform(-0.1, 0.1)  # -10% a +10%
            
            if btc_trend > 0:
                # BTC bullish: alta correlaci√≥n = bueno
                score = 0.5 + (correlation * 0.4) + (btc_trend * 2)
            else:
                # BTC bearish: baja correlaci√≥n = mejor
                score = 0.5 + ((1 - correlation) * 0.3) + abs(btc_trend)
            
            score = max(0.2, min(1.0, score))
            
            if VERBOSE_MARKET_CONTEXT:
                print(f"üîó {symbol} BTC Correlation: {correlation:.2f} | BTC Trend: {btc_trend:+.1%} ‚Üí Score: {score:.3f}")
            return score
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error calculando BTC correlation score: {e}")
            return 0.6
    
    async def calculate_btc_dominance_score(self):
        """
        Calcular score basado en dominancia de BTC
        
        Alta dominancia = BTC fuerte, altcoins d√©biles
        Baja dominancia = altseason, altcoins fuertes
        """
        try:
            # Simular dominancia BTC (valores t√≠picos 40-70%)
            btc_dominance = random.uniform(42, 68)
            
            # Determinar score basado en dominancia
            if btc_dominance > 60:
                # Alta dominancia - Favor BTC, precauci√≥n altcoins
                score = 0.4
                trend = "BTC dominante"
            elif btc_dominance > 50:
                # Dominancia media - Neutral
                score = 0.6
                trend = "Equilibrado"
            else:
                # Baja dominancia - Altseason potencial
                score = 0.8
                trend = "Altseason"
            
            if VERBOSE_MARKET_CONTEXT:
                print(f"üëë BTC Dominance: {btc_dominance:.1f}% | {trend} ‚Üí Score: {score:.3f}")
            return score
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error calculando BTC dominance score: {e}")
            return 0.6
    
    async def save_daily_analysis(self, analysis_results):
        """
        Save daily analysis results to database.
        ‚úÖ PATCH v1.4: Idempotent save - prevents duplicate entries within 24h
        """
        try:
            if not self.trade_db:
                return
            
            now = datetime.now()
            cutoff_time = now - timedelta(hours=24)
            saved_count = 0
            skipped_count = 0
            
            # Store in market_analysis table with special type
            for result in analysis_results:
                symbol = result['symbol']
                score = result['score']
                
                # ‚úÖ PATCH v1.4: Check if similar entry exists in last 24h
                try:
                    # Query recent entries for this symbol
                    recent_entries = self.trade_db.get_recent_analysis(symbol, hours=24)
                    
                    # Check if we already saved this symbol with similar score today
                    duplicate_found = False
                    for entry in recent_entries:
                        # Check if score is very similar (within 1%)
                        if abs(entry.get('final_score', 0) - score) < 0.01:
                            duplicate_found = True
                            break
                    
                    if duplicate_found:
                        skipped_count += 1
                        continue
                        
                except Exception:
                    pass  # If check fails, proceed with save
                
                # Save new entry
                market_data = {
                    'symbol': symbol,
                    'timestamp': result['timestamp'],
                    'price': 0,  # Will be updated during trading
                    'ml_confidence': score,
                    'final_score': score,
                    'market_regime': 'daily_selected',  # Mark as daily analysis result
                    'volume': result.get('volume_24h', 0)
                }
                
                self.trade_db.store_market_analysis(market_data)
                saved_count += 1
            
            if saved_count > 0:
                print(f"üíæ An√°lisis diario guardado: {saved_count} s√≠mbolos")
            if skipped_count > 0:
                print(f"‚è≠Ô∏è  Duplicados omitidos: {skipped_count} s√≠mbolos")
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Error guardando an√°lisis diario: {e}")
    
    async def should_run_daily_analysis(self):
        """
        Check if daily analysis should be run.
        ‚úÖ PATCH v1.4: Enhanced guard to prevent duplicate execution
        """
        try:
            if not self.daily_analysis_enabled:
                return False
            
            now = datetime.now()
            
            # Never run before
            if self.last_daily_analysis is None:
                return True
            
            # ‚úÖ PATCH v1.4: Strict same-day check to prevent duplicates
            if self.last_daily_analysis.date() == now.date():
                return False  # Already ran today, skip
            
            hours_since_last = (now - self.last_daily_analysis).total_seconds() / 3600
            
            # Run if more than 12 hours ago (safety fallback)
            if hours_since_last > 12:
                return True
            
            # Morning analysis (6-10 AM) if not done today
            if 6 <= now.hour <= 10:
                return True
            
            return False
            
        except Exception:
            return True  # Default to running analysis on error
    
    async def run_daily_analysis(self):
        """Run complete daily market analysis"""
        try:
            print("\nüöÄ EJECUTANDO AN√ÅLISIS DIARIO COMPLETO")
            print("=" * 60)
            
            start_time = datetime.now()
            
            # Run market scanner
            selected_symbols = await self.daily_market_scanner()
            
            # Update trading symbols
            if selected_symbols and len(selected_symbols) > 0:
                old_symbols = self.symbols.copy()
                self.symbols = selected_symbols
                
                print(f"\nüîÑ S√çMBOLOS ACTUALIZADOS:")
                print(f"   Anteriores: {len(old_symbols)} s√≠mbolos")
                print(f"   Nuevos: {len(self.symbols)} s√≠mbolos")
                
                # Show changes
                new_symbols = set(self.symbols) - set(old_symbols)
                removed_symbols = set(old_symbols) - set(self.symbols)
                
                if new_symbols:
                    print(f"   ‚ûï Agregados: {', '.join(new_symbols)}")
                if removed_symbols:
                    print(f"   ‚ûñ Removidos: {', '.join(removed_symbols)}")
            
            # Update last analysis time
            self.last_daily_analysis = datetime.now()
            
            elapsed = (datetime.now() - start_time).total_seconds()
            print(f"\n‚úÖ AN√ÅLISIS DIARIO COMPLETADO EN {elapsed:.1f} SEGUNDOS")
            print("=" * 60)
            
            return True
            
        except Exception as e:
            print(f"‚ùå Error en an√°lisis diario completo: {e}")
            return False
    
    async def get_fear_greed_index(self):
        """Get Fear & Greed Index from API"""
        try:
            url = "https://api.alternative.me/fng/"
            response = requests.get(url, timeout=5)
            
            if response.status_code == 200:
                data = response.json()
                fear_greed_value = int(data['data'][0]['value'])
                
                # Convert to 0-1 score (0 = extreme fear, 100 = extreme greed)
                # Optimal range is around 30-70
                if 30 <= fear_greed_value <= 70:
                    return 0.7 + (fear_greed_value - 50) * 0.006  # 0.58 to 0.82
                elif fear_greed_value < 30:
                    # Higher score for fear (buy opportunity) - use config-based base
                    fear_base = self.config.get('ml', {}).get('fear_base_score', 0.8)
                    return fear_base + (30 - fear_greed_value) * 0.01
                else:
                    return 0.4 - (fear_greed_value - 70) * 0.01  # Lower score for greed
            
            return 0.5
            
        except Exception:
            return 0.5
    
    async def get_coingecko_sentiment(self, symbol):
        """Get sentiment from CoinGecko API"""
        try:
            # Convert symbol to CoinGecko format
            coin_id = self.symbol_to_coingecko_id(symbol)
            if not coin_id:
                return None
            
            url = f"https://api.coingecko.com/api/v3/coins/{coin_id}"
            response = requests.get(url, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                
                # Get sentiment indicators
                sentiment_score = 0.5
                
                # Market cap change 24h
                market_data = data.get('market_data', {})
                mc_change_24h = market_data.get('market_cap_change_percentage_24h', 0)
                
                # Price change indicators
                price_change_24h = market_data.get('price_change_percentage_24h', 0)
                price_change_7d = market_data.get('price_change_percentage_7d', 0)
                
                # Community data
                community_data = data.get('community_data', {})
                twitter_followers = community_data.get('twitter_followers', 0)
                
                # Calculate sentiment based on multiple factors
                if mc_change_24h > 5:
                    sentiment_score += 0.2
                elif mc_change_24h > 0:
                    sentiment_score += 0.1
                elif mc_change_24h < -10:
                    sentiment_score -= 0.2
                
                if price_change_7d > 10:
                    sentiment_score += 0.15
                elif price_change_7d < -15:
                    sentiment_score -= 0.15
                
                # Social activity bonus
                if twitter_followers > 100000:
                    sentiment_score += 0.05
                
                return max(0.0, min(sentiment_score, 1.0))
            
            return None
            
        except Exception:
            return None
    
    async def get_momentum_sentiment(self, symbol):
        """Calculate sentiment based on price momentum"""
        try:
            # Get recent price data
            ohlcv = self.exchange.fetch_ohlcv(symbol, '4h', limit=24)  # Last 4 days
            
            if len(ohlcv) < 12:
                return 0.5
            
            closes = np.array([candle[4] for candle in ohlcv])
            
            # Calculate momentum indicators
            short_momentum = (closes[-1] / closes[-6] - 1) * 100  # 24h momentum
            medium_momentum = (closes[-1] / closes[-12] - 1) * 100  # 48h momentum
            
            # Momentum consistency
            recent_changes = np.diff(closes[-6:])
            positive_changes = np.sum(recent_changes > 0)
            momentum_consistency = positive_changes / len(recent_changes)
            
            # Calculate sentiment score
            sentiment = 0.5
            
            # Short-term momentum
            if short_momentum > 5:
                sentiment += 0.2
            elif short_momentum > 0:
                sentiment += 0.1
            elif short_momentum < -10:
                sentiment -= 0.2
            
            # Medium-term momentum
            if medium_momentum > 10:
                sentiment += 0.15
            elif medium_momentum < -15:
                sentiment -= 0.15
            
            # Consistency bonus
            if momentum_consistency > 0.7:
                sentiment += 0.1
            elif momentum_consistency < 0.3:
                sentiment -= 0.1
            
            return max(0.0, min(sentiment, 1.0))
            
        except Exception:
            return 0.5
    
    async def get_market_cap_momentum(self, symbol):
        """Get market cap momentum score"""
        try:
            coin_id = self.symbol_to_coingecko_id(symbol)
            if not coin_id:
                return None
            
            url = f"https://api.coingecko.com/api/v3/coins/{coin_id}"
            response = requests.get(url, timeout=10)
            
            if response.status_code == 200:
                data = response.json()
                market_data = data.get('market_data', {})
                
                # Market cap changes
                mc_change_24h = market_data.get('market_cap_change_percentage_24h', 0)
                mc_change_7d = market_data.get('market_cap_change_percentage_7d', 0)
                
                # Calculate score based on market cap momentum
                score = 0.5
                
                if mc_change_24h > 10:
                    score += 0.3
                elif mc_change_24h > 5:
                    score += 0.2
                elif mc_change_24h > 0:
                    score += 0.1
                elif mc_change_24h < -15:
                    score -= 0.3
                elif mc_change_24h < -10:
                    score -= 0.2
                
                if mc_change_7d > 20:
                    score += 0.2
                elif mc_change_7d < -25:
                    score -= 0.2
                
                return max(0.0, min(score, 1.0))
            
            return None
            
        except Exception:
            return None
    
    async def get_volume_profile_score(self, symbol):
        """Analyze volume profile for scoring"""
        try:
            # Get extended volume data
            ohlcv = self.exchange.fetch_ohlcv(symbol, '1h', limit=168)  # 1 week
            
            if len(ohlcv) < 24:
                return 0.5
            
            volumes = np.array([candle[5] for candle in ohlcv])
            closes = np.array([candle[4] for candle in ohlcv])
            
            # Volume trend analysis
            recent_volume = np.mean(volumes[-24:])  # Last 24h
            week_avg_volume = np.mean(volumes[:-24])  # Previous week
            
            volume_ratio = recent_volume / week_avg_volume if week_avg_volume > 0 else 1.0
            
            # Price-volume correlation
            price_changes = np.diff(closes[-24:])
            volume_changes = np.diff(volumes[-24:])
            
            correlation = 0
            if len(price_changes) > 1:
                try:
                    correlation = np.corrcoef(price_changes, volume_changes)[0, 1]
                    if np.isnan(correlation):
                        correlation = 0
                except:
                    correlation = 0
            
            # Calculate score
            score = 0.5
            
            # Volume increase is generally good
            if volume_ratio > 2.0:
                score += 0.3
            elif volume_ratio > 1.5:
                score += 0.2
            elif volume_ratio > 1.2:
                score += 0.1
            elif volume_ratio < 0.5:
                score -= 0.2
            
            # Positive price-volume correlation is good
            if correlation > 0.3:
                score += 0.2
            elif correlation < -0.3:
                score -= 0.1
            
            return max(0.0, min(score, 1.0))
            
        except Exception:
            return 0.5
    
    async def get_relative_strength_score(self, symbol):
        """Calculate relative strength vs BTC"""
        try:
            if symbol == 'BTC/USDT':
                return 0.7  # BTC gets a good base score
            
            # Get symbol and BTC data
            symbol_ohlcv = self.exchange.fetch_ohlcv(symbol, '4h', limit=48)
            btc_ohlcv = self.exchange.fetch_ohlcv('BTC/USDT', '4h', limit=48)
            
            if len(symbol_ohlcv) < 24 or len(btc_ohlcv) < 24:
                return 0.5
            
            # Calculate returns
            symbol_closes = np.array([candle[4] for candle in symbol_ohlcv])
            btc_closes = np.array([candle[4] for candle in btc_ohlcv])
            
            # 7-day relative performance
            symbol_return = (symbol_closes[-1] / symbol_closes[-42] - 1) if len(symbol_closes) >= 42 else 0
            btc_return = (btc_closes[-1] / btc_closes[-42] - 1) if len(btc_closes) >= 42 else 0
            
            relative_strength = symbol_return - btc_return
            
            # Score based on relative strength
            score = 0.5
            
            if relative_strength > 0.1:  # Outperforming BTC by >10%
                score += 0.3
            elif relative_strength > 0.05:  # Outperforming by >5%
                score += 0.2
            elif relative_strength > 0:  # Outperforming
                score += 0.1
            elif relative_strength < -0.15:  # Underperforming by >15%
                score -= 0.3
            elif relative_strength < -0.1:  # Underperforming by >10%
                score -= 0.2
            
            return max(0.0, min(score, 1.0))
            
        except Exception:
            return 0.5
    
    def symbol_to_coingecko_id(self, symbol):
        """Convert trading symbol to CoinGecko ID"""
        # Simple mapping for major coins
        symbol_map = {
            'BTC/USDT': 'bitcoin',
            'ETH/USDT': 'ethereum',
            'BNB/USDT': 'binancecoin',
            'ADA/USDT': 'cardano',
            'SOL/USDT': 'solana',
            'XRP/USDT': 'ripple',
            'DOGE/USDT': 'dogecoin',
            'MATIC/USDT': 'matic-network',
            'DOT/USDT': 'polkadot',
            'AVAX/USDT': 'avalanche-2',
            'LINK/USDT': 'chainlink',
            'UNI/USDT': 'uniswap',
            'LTC/USDT': 'litecoin',
            'ATOM/USDT': 'cosmos',
            'FTM/USDT': 'fantom',
            'NEAR/USDT': 'near',
            'ALGO/USDT': 'algorand',
            'VET/USDT': 'vechain',
            'ICP/USDT': 'internet-computer',
            'SAND/USDT': 'the-sandbox',
            'MANA/USDT': 'decentraland',
            'CRV/USDT': 'curve-dao-token',
            'AAVE/USDT': 'aave',
            'SUSHI/USDT': 'sushi',
            'COMP/USDT': 'compound-governance-token',
            'TRX/USDT': 'tron',
            'BCH/USDT': 'bitcoin-cash'
        }
        
        return symbol_map.get(symbol)
    
    async def calculate_score(self, symbol, price=None, amount=None):
        """Calculate trading score using Enhanced ML if available"""
        
        # CRITICAL: Calculate effective threshold at the beginning to ensure it's always available
        effective_threshold = self.compute_effective_threshold(enhanced=True, symbol=symbol)
        adjusted_threshold, _ = self.apply_conservative_mode_adjustments(effective_threshold, 0)
        
        # SISTEMA AVANZADO DE VALORACI√ìN CON ETF FLOWS Y ZONAS BTC
        # Generate base confidence con factores macro
        base_score = await self.calculate_advanced_market_score(symbol)
        
        # TRADING 24/7 ACTIVADO - Optimizado basado en an√°lisis de oportunidades globales
        # Los datos muestran que el horario "inactivo" ten√≠a mejor PnL (0.141% vs 0.026%)
        # y representaba 39.5% de las oportunidades perdidas
        current_hour = get_utc_now().hour
        original_base_score = base_score
        
        # Boost diferenciado por mercados globales para optimizar rendimiento
        if 0 <= current_hour < 8:
            # Mercado Asia-Pac√≠fico: Tokio, Singapur, Hong Kong activos
            base_score *= 1.08  # Boost mayor por alta volatilidad asi√°tica
            market_session = "Asia-Pac√≠fico"
        elif 8 <= current_hour < 16:
            # Mercado Europeo: Londres, Frankfurt activos
            base_score *= 1.05  # Boost est√°ndar
            market_session = "Europa"
        elif 16 <= current_hour < 22:
            # Mercado Americano: Wall Street, alta liquidez
            base_score *= 1.06  # Boost alto por m√°xima liquidez
            market_session = "Am√©rica"
        else:  # 22-24
            # After-hours americano, menor liquidez pero oportunidades
            base_score *= 1.03  # Boost moderado
            market_session = "Am√©rica Tarde"
        
        base_score = min(base_score, 1.0)
        
        # Log del mercado activo para monitoreo
        if abs(base_score - original_base_score) > 0.01:  # Solo si hay cambio significativo
            # Log mercado global activo para monitoreo 24/7
            print(f"üåç Mercado {market_session} activo | Boost: {base_score/original_base_score:.3f}x | Score: {base_score:.3f}")
        
        # üöÄ FASE 2: Use existing ML engine with FASE 2 enhancements
        if ML_PREDICTOR_AVAILABLE and price:
            try:
                # Prepare features for FASE 2 model
                trade_amount = amount if amount else 100.0
                
                # Build feature dict (same as simple_ml_predictor)
                features = {
                    'symbol': symbol,
                    'amount': trade_amount,
                    'price': price,
                    'base_confidence': base_score
                }
                
                # Get prediction from ML engine (working predictor)
                from simple_ml_predictor import get_ml_prediction
                
                # Get base prediction
                ml_score, ml_confidence = get_ml_prediction(symbol, trade_amount, price, base_score)
                
                # Apply FASE 2 calibration if available
                if self.fase2_predictor and hasattr(self.fase2_predictor, 'calibrator'):
                    try:
                        import numpy as np
                        # Apply calibration to the raw probability
                        raw_proba = ml_confidence
                        calibrated = self.fase2_predictor.calibrator.predict(np.array([[raw_proba]]))
                        calibrated_score = float(calibrated[0]) if hasattr(calibrated, '__iter__') else float(calibrated)
                        
                        # Log calibration
                        print(f"ML_CALIB: rt={MODEL_RUNTIME_ID} raw={raw_proba:.3f} calib={calibrated_score:.3f}")
                        final_score = calibrated_score
                        ml_confidence = calibrated_score
                    except Exception as e:
                        # Fallback to uncalibrated
                        print(f"‚ö†Ô∏è  Calibration failed: {e}, using raw={ml_confidence:.3f}")
                        final_score = ml_confidence
                else:
                    # No calibration available, use raw
                    final_score = ml_confidence
                
                # Apply staleness penalty
                penalized_confidence, staleness_reason = self.apply_staleness_penalty(final_score, symbol)
                
                # Compact decision log format
                timestamp = get_utc_now().isoformat()
                
                # Apply FASE 2 threshold adjustments
                if self.threshold_mgr:
                    regime = 'LOW'  # Default regime
                    adjusted_threshold, thr_meta = self.threshold_mgr.get_effective(
                        symbol=symbol,
                        regime=regime,
                        now_utc=get_utc_now(),
                        safe_mode=self.safe_mode
                    )
                    print(f"THR_APPLY: {symbol} base={self.base_min_confidence:.3f} ‚Üí eff={adjusted_threshold:.3f}")
                
                action = "BUY" if penalized_confidence >= adjusted_threshold else "HOLD"
                reason = staleness_reason.value if staleness_reason else "below_threshold" if action == "HOLD" else "approved"
                
                print(f"[{timestamp}] {symbol} | conf={penalized_confidence:.3f} {'>' if action == 'BUY' else '<'} thr={adjusted_threshold:.3f} | action={action} | reason={reason} | model={MODEL_RUNTIME_ID}")
                
                if penalized_confidence >= adjusted_threshold:
                    self.add_decision(penalized_confidence, signal='buy', signal_used='new_model_fase2')
                    self.log_ml_decision(
                        signal_used="new_model_fase2",
                        final_confidence=penalized_confidence,
                        effective_threshold=adjusted_threshold,
                        reason_for_bypass=staleness_reason,
                        symbol=symbol,
                        trade_decision="buy"
                    )
                    return penalized_confidence
                else:
                    self.add_decision(penalized_confidence, signal='hold', signal_used='new_model_fase2')
                    self.log_ml_decision(
                        signal_used="new_model_fase2",
                        final_confidence=penalized_confidence,
                        effective_threshold=adjusted_threshold,
                        reason_for_bypass=BypassReason.THRESHOLD,
                        symbol=symbol,
                        trade_decision="hold"
                    )
                    
                    # Store HOLD opportunity for auditor√≠a (PRODUCTION-GRADE)
                    if self.trade_db:
                        try:
                            import json
                            now_utc = get_utc_now()
                            
                            # Get signal timestamp from most recent market data
                            signal_ts = now_utc
                            latency_ms = 100.0  # Default estimate (typical exchange latency)
                            
                            # Try multiple methods to get signal timestamp
                            if not self.simulation_mode and hasattr(self, 'exchange'):
                                try:
                                    # Method 1: Try ticker timestamp (fastest, most accurate)
                                    ticker = self.exchange.fetch_ticker(symbol)
                                    if ticker and 'timestamp' in ticker and ticker['timestamp']:
                                        signal_ts = datetime.fromtimestamp(ticker['timestamp'] / 1000, tz=timezone.utc)
                                        latency_ms = max(1.0, (now_utc - signal_ts).total_seconds() * 1000)  # Min 1ms
                                except:
                                    try:
                                        # Method 2: Fallback to OHLCV
                                        recent_ohlcv = self.exchange.fetch_ohlcv(symbol, '1m', limit=1)
                                        if recent_ohlcv and len(recent_ohlcv) > 0:
                                            signal_ts_ms = recent_ohlcv[0][0]
                                            signal_ts = datetime.fromtimestamp(signal_ts_ms / 1000, tz=timezone.utc)
                                            latency_ms = max(1.0, (now_utc - signal_ts).total_seconds() * 1000)  # Min 1ms
                                    except:
                                        # Method 3: Estimate based on typical exchange delay
                                        signal_ts = now_utc - timedelta(milliseconds=100)
                                        latency_ms = 100.0
                            else:
                                # Simulation mode: use estimated latency
                                signal_ts = now_utc - timedelta(milliseconds=100)
                                latency_ms = 100.0
                            
                            # Threshold breakdown - Capture ALL modifiers
                            # Start with absolute base (before any adjustments)
                            absolute_base = max(self.base_min_confidence, 0.500)
                            
                            # Calculate each layer of adjustments
                            safe_mode_boost = 0.0
                            if self.safe_mode:
                                safe_trading = self.safe_mode_config.get('trading', {})
                                safe_ml = self.safe_mode_config.get('ml', {})
                                critical_flag = safe_ml.get('critical_mode', False) or safe_trading.get('critical_mode', False)
                                safe_mode_boost = 0.20 if critical_flag else 0.05
                            
                            # Symbol-specific adjustments
                            symbol_adjustment = 0.0
                            if symbol:
                                symbol_base = symbol.split('/')[0]
                                high_vol_symbols = self.config.get('symbol_specific', {}).get('high_volatility_symbols', [])
                                stable_symbols = self.config.get('symbol_specific', {}).get('stable_symbols', [])
                                if symbol_base in high_vol_symbols:
                                    symbol_adjustment = 0.02
                                elif symbol_base in stable_symbols:
                                    symbol_adjustment = -0.02
                            
                            # Conservative mode boost
                            conservative_boost = self.conservative_mode_state.get('threshold_boost', 0.0) if self.conservative_mode_state.get('active', False) else 0.0
                            
                            # Staleness penalty and TTL calculation
                            staleness_penalty = final_score - penalized_confidence if staleness_reason else 0.0
                            
                            # Calculate TTL remaining and data age
                            ttl_remaining_s = None
                            max_age_minutes = 0
                            if self.market_enabled:
                                age_min = self._calculate_data_age_minutes('market')
                                ttl_min = self.staleness_config['market_data_ttl_minutes']
                                max_age_minutes = max(max_age_minutes, age_min)
                                if ttl_remaining_s is None or (ttl_min - age_min) * 60 < ttl_remaining_s:
                                    ttl_remaining_s = max(0, (ttl_min - age_min) * 60)
                            
                            # Calculate base_threshold (before conservative mode)
                            base_threshold = absolute_base + safe_mode_boost + symbol_adjustment
                            
                            # Build modifiers dict
                            thr_modifiers = {
                                'absolute_base': absolute_base,
                                'safe_mode': safe_mode_boost,
                                'symbol_specific': symbol_adjustment,
                                'conservative_mode': conservative_boost,
                                'staleness_penalty': staleness_penalty,
                                'total_adjustment': adjusted_threshold - absolute_base
                            }
                            
                            # Reasons
                            reason_primary = reason
                            reasons_all = [reason]
                            if staleness_reason:
                                reasons_all.append(staleness_reason.value)
                            
                            # Model info
                            model_runtime_id = MODEL_RUNTIME_ID
                            model_hash = GLOBAL_MODEL_INFO.get('hash', 'unknown')
                            feature_set_version = GLOBAL_MODEL_INFO.get('feature_version', 'v2')
                            
                            # Market context
                            regime = 'UNKNOWN'  # TODO: Get from market regime detector
                            volatility_pct = 0.0  # TODO: Calculate from recent price data
                            
                            opportunity_data = {
                                # Original fields
                                'timestamp': now_utc.isoformat(),
                                'symbol': symbol,
                                'action': 'HOLD',
                                'ml_confidence': penalized_confidence,
                                'confidence_threshold': adjusted_threshold,
                                'final_score': ml_score,
                                'reason': reason,
                                'model_version': GLOBAL_MODEL_INFO['model_version'],
                                'price': price if price else 0.0,
                                
                                # Extended fields (production-grade)
                                'thr_base': base_threshold,
                                'thr_effective': adjusted_threshold,
                                'thr_modifiers': json.dumps(thr_modifiers),
                                'signal_ts_utc': signal_ts.isoformat(),
                                'decision_ts_utc': now_utc.isoformat(),
                                'latency_ms': latency_ms,
                                'ttl_remaining_s': None,  # TODO: Calculate from signal age
                                'reason_primary': reason_primary,
                                'reasons_all': json.dumps(reasons_all),
                                'model_runtime_id': model_runtime_id,
                                'model_hash': model_hash,
                                'feature_set_version': feature_set_version,
                                'feature_count': 50,  # FASE 2 model uses 50 features
                                'imputed_fields': json.dumps([]),  # TODO: Track imputed fields
                                'regime': regime,
                                'volatility_pct': volatility_pct,
                                'hour_utc': now_utc.hour,
                                'cooldown_active': 0,  # TODO: Check cooldown status
                                'position_cap_hit': 0,  # TODO: Check position cap
                                'top_k_rank': None  # TODO: Rank in current cycle
                            }
                            self.trade_db.store_opportunity(opportunity_data)
                        except Exception as e:
                            # Log error but don't crash
                            print(f"‚ö†Ô∏è  Failed to store opportunity: {e}")
                            pass
                    
                    return penalized_confidence
                    
            except Exception as e:
                print(f"‚ö†Ô∏è  NEW MODEL prediction failed for {symbol}: {e}, using fallback")
                import traceback
                traceback.print_exc()
        
        # Try Enhanced ML first if available
        enhanced_ml_failed = False
        enhanced_ml_available = self.is_enhanced_ml_available()
        
        if enhanced_ml_available and price and amount:
            try:
                ml_prob, enhanced_confidence = get_offline_enhanced_prediction(
                    symbol, amount, price, base_score
                )
                
                # ============================================================================
                # FIX #2: ENHANCED COMBINER SAFETY - Evitar sobre-penalizaci√≥n
                # ============================================================================
                improvement = enhanced_confidence - base_score
                
                # Regla 1: Solo acepta enhancement si mejora >= +0.02
                if improvement < 0.02:
                    enhanced_confidence = base_score
                    print(f"üîç Enhancement rejected (Œî={improvement:+.3f}), using base={base_score:.3f}")
                else:
                    # Regla 2: En LOW regime, cap la influencia de factores externos
                    try:
                        # Detectar r√©gimen actual
                        regime_current = self.get_current_regime() if hasattr(self, 'get_current_regime') else 'MID'
                        
                        if regime_current == 'LOW':
                            max_delta = 0.05
                            delta = enhanced_confidence - base_score
                            capped_delta = max(-max_delta, min(max_delta, delta))
                            enhanced_confidence = base_score + capped_delta
                            
                            if abs(delta - capped_delta) > 0.001:
                                print(f"üîç LOW regime: capped Œî={delta:+.3f} ‚Üí {capped_delta:+.3f}")
                    except Exception as e:
                        print(f"‚ö†Ô∏è  Regime cap error: {e}")
                
                print(f"üéØ Combiner: base={base_score:.3f} ‚Üí enhanced={enhanced_confidence:.3f} (Œî={improvement:+.3f})")
                
                # Update copy trading data timestamp (enhanced ML includes copy trading analysis)
                if self.copy_enabled:
                    self.last_data_timestamps['copy_trading'] = get_utc_now()
                
                # Apply staleness penalty
                penalized_confidence, staleness_reason = self.apply_staleness_penalty(enhanced_confidence, symbol)
                
                # If hard limit triggered, staleness penalty already returned 0.0
                if staleness_reason == BypassReason.STALE_DATA_HARD_LIMIT:
                    return 0.0
                
                # Check conservative mode trigger before threshold check
                self.check_conservative_mode_trigger(penalized_confidence)
                
                # Use the effective threshold calculated at the beginning
                # adjusted_threshold was already calculated at the start of the function
                
                # Bloquear trade si Enhanced ML no supera umbral efectivo (adjusted for conservative mode)
                if penalized_confidence < adjusted_threshold:
                    # üîß PATCH v1.5 - Fix #5: Register decision for monitoring
                    self.add_decision(penalized_confidence, signal='hold', signal_used='enhanced')
                    reason = staleness_reason if staleness_reason else BypassReason.THRESHOLD
                    self.log_ml_decision(
                        signal_used="enhanced",
                        final_confidence=penalized_confidence,
                        effective_threshold=adjusted_threshold,
                        reason_for_bypass=reason,
                        symbol=symbol,
                        trade_decision="hold"
                    )
                    
                    # üî¨ Shadow Mode: Log FASE 2 prediction for rejected trades too
                    if self.shadow_mode:
                        try:
                            market_data = await self.get_market_data_for_ml(symbol)
                            if market_data is not None and len(market_data) > 0:
                                self.shadow_mode.log_prediction(
                                    symbol=symbol,
                                    market_data=market_data,
                                    production_decision='hold',
                                    production_confidence=penalized_confidence,
                                    why_skipped=reason.value if reason else 'threshold'
                                )
                        except Exception as e:
                            print(f"‚ö†Ô∏è  Shadow Mode logging error: {e}")
                    
                    # Return actual confidence for display, not 0.0
                    return penalized_confidence
                
                # Successful enhanced ML decision
                # üîß PATCH v1.5 - Fix #5: Register decision for monitoring
                self.add_decision(penalized_confidence, signal='buy', signal_used='enhanced')
                self.log_ml_decision(
                    signal_used="enhanced",
                    final_confidence=penalized_confidence,
                    effective_threshold=adjusted_threshold,
                    reason_for_bypass=staleness_reason,
                    symbol=symbol,
                    trade_decision="buy"
                )
                
                # ‚úÖ PATCH v1.1 ‚Äì Check and update safe_mode dynamically
                self.safe_mode = self.check_safe_mode(penalized_confidence)
                
                # üî¨ Shadow Mode: Log FASE 2 prediction in parallel
                if self.shadow_mode:
                    try:
                        market_data = await self.get_market_data_for_ml(symbol)
                        if market_data is not None and len(market_data) > 0:
                            self.shadow_mode.log_prediction(
                                symbol=symbol,
                                market_data=market_data,
                                production_decision='buy',
                                production_confidence=penalized_confidence,
                                why_skipped=None
                            )
                    except Exception as e:
                        print(f"‚ö†Ô∏è  Shadow Mode logging error: {e}")
                
                # Confidence added to continuous monitoring via calculate_continuous_monitoring_metrics()
                
                return penalized_confidence
                
            except Exception as e:
                # Enhanced ML error - mark for fallback to basic ML
                enhanced_ml_failed = True
                print(f"‚ö†Ô∏è  Enhanced ML error for {symbol}: {e}")
                print(f"üîÑ Falling back to basic ML...")
                
        # Fallback to Basic ML if Enhanced ML not available or failed
        if ML_PREDICTOR_AVAILABLE and price and amount and (not enhanced_ml_available or enhanced_ml_failed):
            try:
                ml_prob, final_confidence = get_ml_prediction(symbol, amount, price, base_score)
                
                # Use the effective threshold calculated at the beginning
                
                # Apply staleness penalty to basic ML as well
                penalized_confidence, staleness_reason = self.apply_staleness_penalty(final_confidence, symbol)
                
                # If hard limit triggered, staleness penalty already returned 0.0
                if staleness_reason == BypassReason.STALE_DATA_HARD_LIMIT:
                    return 0.0
                
                # Determine signal_used based on fallback reason
                signal_used = "basic_ml"  # Always basic_ml when using fallback
                
                # Bloquear trade si ML b√°sico no supera umbral efectivo
                if penalized_confidence < effective_threshold:
                    reason = staleness_reason if staleness_reason else BypassReason.THRESHOLD
                    self.log_ml_decision(
                        signal_used=signal_used,
                        final_confidence=penalized_confidence,
                        effective_threshold=effective_threshold,
                        reason_for_bypass=reason,
                        symbol=symbol,
                        trade_decision="hold"
                    )
                    return 0.0
                
                # Successful basic ML fallback decision
                # Log structured fallback information
                self.log_ml_decision(
                    signal_used=signal_used,
                    final_confidence=penalized_confidence,
                    effective_threshold=effective_threshold,
                    reason_for_bypass=staleness_reason,
                    symbol=symbol,
                    trade_decision="buy"
                )
                
                # ‚úÖ PATCH v1.1 ‚Äì Check and update safe_mode dynamically
                self.safe_mode = self.check_safe_mode(penalized_confidence)
                
                # Log fallback event with structured format
                if enhanced_ml_failed:
                    print(f"üîÑ ML_FALLBACK: enhanced_ml_error=true, fallback_to=basic_ml, "
                          f"symbol={symbol}, confidence={penalized_confidence:.3f}, "
                          f"threshold={effective_threshold:.3f}, success=true")
                elif not enhanced_ml_available:
                    print(f"üîÑ ML_FALLBACK: enhanced_ml_available=false, using=basic_ml, "
                          f"symbol={symbol}, confidence={penalized_confidence:.3f}, "
                          f"threshold={effective_threshold:.3f}")
                
                return penalized_confidence
                
            except Exception as e:
                # Basic ML error - complete ML failure
                self.log_ml_decision(
                    signal_used="none",
                    final_confidence=0.0,
                    effective_threshold=effective_threshold,
                    reason_for_bypass=BypassReason.BASIC_ML_ERROR,
                    symbol=symbol,
                    trade_decision="hold"
                )
                print(f"‚ùå ML_FALLBACK: enhanced_ml_failed=true, basic_ml_failed=true, "
                      f"symbol={symbol}, error='{str(e)}', trading_disabled=true")
                return 0.0
        else:
            # ML unavailable - neither enhanced nor basic ML available
            # Use the effective threshold calculated at the beginning
            self.log_ml_decision(
                signal_used="none",
                final_confidence=0.0,
                effective_threshold=effective_threshold,
                reason_for_bypass=BypassReason.ML_UNAVAILABLE,
                symbol=symbol,
                trade_decision="hold"
            )
            print(f"üîÑ ML_FALLBACK: enhanced_ml_available={enhanced_ml_available}, "
                  f"basic_ml_available={ML_PREDICTOR_AVAILABLE}, "
                  f"symbol={symbol}, trading_disabled=true")
            return 0.0
    
    async def get_market_data_for_ml(self, symbol):
        """Get market data formatted for ML prediction"""
        try:
            # Get OHLCV data for the last 100 periods (1m timeframe)
            if not self.simulation_mode:
                ohlcv = self.exchange.fetch_ohlcv(symbol, '1m', limit=100)
            else:
                # Simulate OHLCV data for testing
                import pandas as pd
                current_time = datetime.now()
                timestamps = [(current_time - timedelta(minutes=i)).timestamp() * 1000 for i in range(100, 0, -1)]
                base_price = 50000 if 'BTC' in symbol else 3000 if 'ETH' in symbol else 1
                ohlcv = []
                for ts in timestamps:
                    price = base_price * (1 + random.uniform(-0.02, 0.02))
                    ohlcv.append([ts, price, price * 1.01, price * 0.99, price, random.uniform(100, 1000)])
            
            if len(ohlcv) < 50:  # Need at least 50 data points
                return None
            
            # Convert to DataFrame
            import pandas as pd
            df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            
            # ‚úÖ Add symbol column for Shadow Mode
            df['symbol'] = symbol
            
            # ‚úÖ Add missing features for Shadow Mode
            df['quote_volume'] = df['volume'] * df['close']  # Quote volume = base_volume * price
            df['returns'] = df['close'].pct_change()  # Price returns
            
            return df
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Error obteniendo datos de mercado para ML: {e}")
            return None
    
    def save_market_analysis(self, symbol, price, score):
        """Save market analysis for ML training"""
        if not self.trade_db:
            return
        
        try:
            # Create analysis data
            analysis_data = {
                'symbol': symbol,
                'timestamp': datetime.now().isoformat(),
                'price': price,
                'ml_confidence': score,
                'final_score': score,
                'recommended_action': 'BUY' if score > self.compute_effective_threshold(enhanced=ENHANCED_ML_AVAILABLE, symbol=symbol) else 'HOLD',
                'created_at': datetime.now().isoformat()
            }
            
            # Save to database
            self.trade_db.store_market_analysis(analysis_data)
            
        except Exception as e:
            print(f"‚ùå Error guardando an√°lisis de mercado: {e}")
    
    async def check_ml_retraining(self):
        """
        Check if ML models need retraining
        PATCH v1.2 ‚Äì Safe Async Execution
        """
        try:
            current_time = datetime.now()
            
            # Check if it's time to retrain
            if (self.last_retrain_time is None or 
                (current_time - self.last_retrain_time).total_seconds() >= self.retrain_frequency_hours * 3600):
                
                # Check if we have enough trades for retraining
                should_retrain_result = self.ml_engine.should_retrain()
                
                # Handle both coroutine and direct bool return
                if asyncio.iscoroutine(should_retrain_result):
                    should_retrain = await should_retrain_result
                else:
                    should_retrain = should_retrain_result
                
                if should_retrain:
                    print(f"\nüß† INICIANDO REENTRENAMIENTO ML...")
                    print(f"   ‚è∞ √öltima vez: {self.last_retrain_time or 'Nunca'}")
                    print(f"   üìä Frecuencia: cada {self.retrain_frequency_hours}h")
                    
                    # Perform retraining
                    retrain_result = self.ml_engine.retrain_models()
                    
                    # Handle both coroutine and direct result return
                    if asyncio.iscoroutine(retrain_result):
                        result = await retrain_result
                    else:
                        result = retrain_result
                    
                    # Check success - handle both bool and RetrainingResult object
                    if hasattr(result, 'success'):
                        success = result.success
                    elif isinstance(result, bool):
                        success = result
                    else:
                        success = bool(result)
                    
                    if success:
                        self.last_retrain_time = current_time
                        print(f"‚úÖ Reentrenamiento ML completado exitosamente")
                    else:
                        print(f"‚ö†Ô∏è  Reentrenamiento ML fall√≥, reintentando en 1h")
                        # Set retry in 1 hour instead of full frequency
                        self.last_retrain_time = current_time - timedelta(hours=self.retrain_frequency_hours - 1)
                else:
                    print(f"‚ö†Ô∏è  No hay suficientes trades para reentrenamiento ML")
                    self.last_retrain_time = current_time  # Reset timer
                    
        except Exception as e:
            print(f"‚ùå Error en scheduler de reentrenamiento ML: {e}")
    
    async def run_analytics_update(self):
        """Ejecutar an√°lisis peri√≥dico del sistema con Analytics Engine"""
        if not self.analytics_engine:
            return None
        
        try:
            print(f"\nüìä EJECUTANDO AN√ÅLISIS DEL SISTEMA...")
            print(f"   üîÑ An√°lisis #{self.analytics_counter // self.analytics_interval}")
            
            # Ejecutar an√°lisis completo
            analysis = await self.analytics_engine.run_comprehensive_analysis()
            
            # Extraer m√©tricas clave
            perf = analysis.get('performance_metrics', {})
            ml_analytics = analysis.get('ml_analytics', {})
            
            # Log resultados principales
            print(f"\nüìà RESULTADOS DEL AN√ÅLISIS:")
            print(f"   üìä Trades analizados: {perf.get('total_trades', 0)}")
            print(f"   ‚úÖ Trades ganadores: {perf.get('winning_trades', 0)}")
            print(f"   ‚ùå Trades perdedores: {perf.get('losing_trades', 0)}")
            print(f"   üìà Win rate: {perf.get('win_rate', 0):.2%}")
            print(f"   üí∞ Total PnL: ${perf.get('total_pnl', 0):.2f}")
            print(f"   üìä Avg PnL/trade: ${perf.get('avg_pnl_per_trade', 0):.2f}")
            print(f"   üìâ Max drawdown: {perf.get('max_drawdown', 0):.2%}")
            print(f"   üéØ Sharpe ratio: {perf.get('sharpe_ratio', 0):.2f}")
            
            if ml_analytics.get('model_accuracy', 0) > 0:
                print(f"\nüß† ML ANALYTICS:")
                print(f"   üéØ Model accuracy: {ml_analytics.get('model_accuracy', 0):.2%}")
                print(f"   üìä Avg confidence: {ml_analytics.get('avg_confidence', 0):.2%}")
                print(f"   üîÑ Concept drift: {ml_analytics.get('concept_drift_score', 0):.3f}")
            
            return analysis
            
        except Exception as e:
            print(f"‚ùå Error ejecutando analytics: {e}")
            import traceback
            traceback.print_exc()
            return None
    
    def load_runtime_adjustments(self):
        """Cargar y aplicar ajustes din√°micos del analytics (FASE 2)"""
        try:
            if not os.path.exists(self.runtime_config_path):
                return None
            
            with open(self.runtime_config_path, 'r') as f:
                config = json.load(f)
            
            adjustments = config.get('adjustments', {})
            insights = config.get('analytics_insights', {})
            
            # Aplicar ajustes
            if 'confidence_threshold' in adjustments:
                old_threshold = self.base_min_confidence
                self.base_min_confidence = adjustments['confidence_threshold']
                print(f"üîß Threshold ajustado: {old_threshold:.2f} ‚Üí {self.base_min_confidence:.2f}")
            
            if 'position_size_multiplier' in adjustments:
                self.position_multiplier = adjustments['position_size_multiplier']
                print(f"üìä Position multiplier: {self.position_multiplier:.2f}x")
            
            if adjustments.get('pause_trading', False):
                print(f"‚ö†Ô∏è  TRADING PAUSADO por analytics")
                print(f"   Raz√≥n: Win rate bajo ({insights.get('recent_win_rate', 0):.1%})")
                self.trading_paused = True
            else:
                if self.trading_paused:
                    print(f"‚úÖ Trading reanudado por analytics")
                self.trading_paused = False
            
            # Log insights
            print(f"\nüìä ANALYTICS INSIGHTS:")
            print(f"   Win rate: {insights.get('recent_win_rate', 0):.1%}")
            print(f"   Avg PnL/trade: ${insights.get('avg_pnl_per_trade', 0):.2f}")
            print(f"   Risk level: {adjustments.get('risk_level', 'unknown')}")
            print(f"   Recommended: {insights.get('recommended_action', 'continue')}")
            print(f"   Sharpe ratio: {insights.get('sharpe_ratio', 0):.2f}")
            print(f"   Max drawdown: {insights.get('max_drawdown', 0):.1%}")
            
            return config
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Error cargando ajustes din√°micos: {e}")
            return None
    
    async def get_market_data_for_ml(self, symbol):
        """Get market data formatted for ML prediction"""
        try:
            # Get OHLCV data for the last 100 periods (1m timeframe)
            if not self.simulation_mode and hasattr(self, 'exchange'):
                ohlcv = self.exchange.fetch_ohlcv(symbol, '1m', limit=100)
            else:
                # Simulate OHLCV data for simulation mode
                import pandas as pd
                current_time = datetime.now()
                timestamps = [(current_time - timedelta(minutes=i)).timestamp() * 1000 for i in range(100, 0, -1)]
                base_price = 50000 if 'BTC' in symbol else 3000 if 'ETH' in symbol else 1
                ohlcv = []
                for ts in timestamps:
                    price = base_price * (1 + random.uniform(-0.02, 0.02))
                    ohlcv.append([ts, price, price * 1.01, price * 0.99, price, random.uniform(100, 1000)])
            
            if len(ohlcv) < 50:  # Need at least 50 data points
                return None
            
            # Convert to DataFrame
            import pandas as pd
            df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            
            # ‚úÖ Add symbol column for Shadow Mode
            df['symbol'] = symbol
            
            # ‚úÖ Add missing features for Shadow Mode
            df['quote_volume'] = df['volume'] * df['close']  # Quote volume = base_volume * price
            df['returns'] = df['close'].pct_change()  # Price returns
            
            return df
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Error obteniendo datos de mercado para ML: {e}")
            return None

    async def analyze_symbol(self, symbol):
        """
        Analyze symbol for opportunities with Enhanced Policy Bundle v2.0
        FLUJO CORREGIDO: threshold ‚Üí filtros ‚Üí decisi√≥n ‚Üí log
        """
        try:
            # PASO 0: Filtrar stablecoins
            if is_stable_pair(symbol):
                print(f"‚è≠Ô∏è  {symbol}: Stablecoin pair - SKIP")
                return None
            
            # Get price (simulated if needed)
            if self.simulation_mode:
                base_prices = {
                    'BTC/USDT': 95000, 'ETH/USDT': 3200, 'BNB/USDT': 650,
                    'ADA/USDT': 0.85, 'SOL/USDT': 180, 'XRP/USDT': 0.52,
                    'DOGE/USDT': 0.08, 'MATIC/USDT': 0.45, 'DOT/USDT': 7.2,
                    'AVAX/USDT': 28
                }
                current_price = base_prices.get(symbol, 100) * random.uniform(0.98, 1.02)
            else:
                ticker = self.exchange.fetch_ticker(symbol)
                current_price = ticker['last']
            
            # Calculate estimated trade amount for ML
            estimated_amount = self.balance_usdt * self.max_position_percent
            
            # === ENHANCED POLICY BUNDLE v2.0 INTEGRATION (FLUJO CORREGIDO) ===
            if hasattr(self, 'enhanced_policy') and self.enhanced_policy and self.enhanced_policy.enabled:
                # PASO 1: Obtener score base del ML
                base_score = await self.calculate_score(symbol, current_price, estimated_amount)
                
                # PASO 2: Calibrar probabilidad (si est√° habilitado)
                calibrated_score = self.enhanced_policy.preprocess_probability(base_score)
                
                if abs(calibrated_score - base_score) > 0.01:
                    print(f"üîß Calibraci√≥n: {base_score:.3f} ‚Üí {calibrated_score:.3f}")
                
                # PASO 2.5: Session Gates - Ajustar score por sesi√≥n
                if RISK_MANAGEMENT_AVAILABLE:
                    try:
                        from signals.macro_gates import apply_session_adjustments
                        calibrated_score, threshold_bump = apply_session_adjustments(calibrated_score)
                        if threshold_bump > 0:
                            print(f"üìÖ Session adjustment: threshold +{threshold_bump:.3f}")
                    except Exception as e:
                        print(f"‚ö†Ô∏è  Session gates error: {e}")
                        threshold_bump = 0
                else:
                    threshold_bump = 0
                
                # V2: Enhanced Session Gates with WR tracking
                if RISK_MANAGEMENT_V2_AVAILABLE:
                    try:
                        from datetime import datetime
                        
                        # Get current session
                        hour_utc = datetime.utcnow().hour
                        session = "Asia" if 0 <= hour_utc < 8 else "Europa" if 8 <= hour_utc < 16 else "America"
                        
                        # Get session stats (simplified - you may want to implement proper tracking)
                        session_wr = 0.52  # Placeholder - implement proper session WR tracking
                        global_wr = 0.55   # Placeholder - implement proper global WR tracking
                        
                        # Apply V2 session adjustment
                        base_threshold = 0.70
                        adjusted_threshold = threshold_by_session(base_threshold, session_wr, global_wr)
                        
                        if adjusted_threshold != base_threshold:
                            threshold_adjustment = adjusted_threshold - base_threshold
                            calibrated_score -= threshold_adjustment  # Lower score = higher threshold
                            print(f"üîç SESSION_V2: {session} session, threshold adjusted by {threshold_adjustment:+.3f}")
                    
                    except Exception as e:
                        print(f"‚ö†Ô∏è  V2 session adjustment error: {e}")
                
                # PASO 3: Obtener datos hist√≥ricos y normalizar
                try:
                    series_raw = await self.get_market_data_for_ml(symbol)
                    series, n = _normalize_series(series_raw)
                    if series is None or len(series) < 20:
                        series = []
                except Exception as e:
                    print(f"‚ö†Ô∏è  Error obteniendo datos hist√≥ricos: {e}")
                    series, n = None, 0
                
                # PASO 4: Determinar r√©gimen de volatilidad
                try:
                    if series is None or n < 20:
                        regime = 'MID'
                    else:
                        regime = self.enhanced_policy.get_regime(symbol, series)
                except Exception as e:
                    print(f"‚ö†Ô∏è  Error calculando r√©gimen: {e}")
                    regime = 'MID'
                
                # PASO 4.5: Trend Day Gates - Verificar si el setup es permitido
                if RISK_MANAGEMENT_AVAILABLE:
                    try:
                        setup_type = 'scalp'  # Default setup type
                        allowed, meta = allow_setup(setup_type, symbol, series)
                        if not allowed:
                            print(f"üìä {symbol}: decision=HOLD, reason=trend_day_block, meta={meta}")
                            self.save_market_analysis(symbol, current_price, calibrated_score)
                            return None
                    except Exception as e:
                        print(f"‚ö†Ô∏è  Trend day gates error: {e}")
                
                # V2: Enhanced Trend Day Gates with ATR-based detection
                if RISK_MANAGEMENT_V2_AVAILABLE:
                    try:
                        # Calculate trend score (simplified - you may want to get real SMA/ATR)
                        sma_20 = current_price * 0.998  # Placeholder
                        atr_14 = current_price * 0.02   # Placeholder
                        
                        trend_score = calculate_trend_score(current_price, sma_20, atr_14)
                        
                        # Check if should block mean reversion
                        setup_type = 'scalp'  # Default setup type
                        should_block, block_reason = should_block_mean_reversion(setup_type, trend_score)
                        
                        if should_block:
                            print(f"üìä {symbol}: decision=HOLD, reason=V2_{block_reason}")
                            self.save_market_analysis(symbol, current_price, calibrated_score)
                            return None
                        
                        if abs(trend_score) > 2.0:  # Strong trend
                            direction = "up" if trend_score > 0 else "down"
                            print(f"üìä {symbol}: V2 trend detected - {direction} trend (score={trend_score:.2f})")
                    
                    except Exception as e:
                        print(f"‚ö†Ô∏è  V2 trend day gate error: {e}")
                
                # PASO 5: Calcular ATR
                try:
                    if series is not None and n > 14:
                        atr = self.enhanced_policy.calculate_atr(series)
                    else:
                        atr = 0.012
                except Exception as e:
                    print(f"‚ö†Ô∏è  Error calculando ATR: {e}")
                    atr = 0.012
                
                # ============================================================================
                # FIX #1: THRESHOLD LOCK - Evitar race conditions
                # ============================================================================
                # Calcular threshold UNA SOLA VEZ al inicio y usarlo en toda la evaluaci√≥n
                # Esto evita que cambios de estado (safe mode, etc.) alteren el threshold
                # durante el an√°lisis del s√≠mbolo
                threshold_locked = self.compute_threshold_final(symbol, regime, self.safe_mode)
                print(f"üîí Threshold locked: {threshold_locked:.3f} for {symbol}")
                
                # PASO 6: Usar threshold LOCKED para toda la evaluaci√≥n
                threshold_final = threshold_locked
                
                # PASO 7: Verificar si pasa el threshold
                if calibrated_score < threshold_final:
                    # ‚úÖ MEJORA 5: Record throughput health
                    if self.throughput_health:
                        self.throughput_health.record_signal('HOLD')
                    
                    # Log consolidado de rechazo
                    print(f"üìä {symbol}: score={calibrated_score:.3f}, threshold={threshold_final:.3f}, "
                          f"regime={regime}, decision=HOLD, reason=score_below_threshold")
                    
                    self.save_market_analysis(symbol, current_price, calibrated_score)
                    return None
                
                # PASO 8: Aplicar filtros adicionales
                book = self.enhanced_policy.get_mock_book(symbol, current_price)
                
                # Verificar filtros con score para deduplicaci√≥n
                filters_pass = self.enhanced_policy.should_allow_trade(
                    symbol, current_price, atr, book, series, regime, score=calibrated_score
                )
                
                if not filters_pass:
                    # ‚úÖ MEJORA 5: Record throughput health
                    if self.throughput_health:
                        self.throughput_health.record_signal('HOLD')
                    
                    # Log consolidado de rechazo por filtros
                    print(f"üìä {symbol}: score={calibrated_score:.3f}, threshold={threshold_final:.3f}, "
                          f"regime={regime}, decision=HOLD, reason=blocked_by_filters")
                    
                    self.save_market_analysis(symbol, current_price, calibrated_score)
                    return None
                
                # PASO 9: Calcular m√©tricas adicionales
                suggested_size = self.enhanced_policy.calculate_position_size(
                    calibrated_score, threshold_final, atr
                )
                tp, sl = self.enhanced_policy.get_tp_sl_levels(current_price, atr, 'long', regime)
                
                # PASO 10: Registrar cooldown y se√±al
                self.enhanced_policy.record_trade_entry(symbol, current_price, atr)
                self.enhanced_policy.record_signal(symbol, calibrated_score)
                
                # PASO 11: Log consolidado de OPORTUNIDAD (decisi√≥n final)
                print(f"‚úÖ {symbol}: score={calibrated_score:.3f}, threshold={threshold_final:.3f}, "
                      f"regime={regime}, atr={atr*100:.2f}%, decision=BUY")
                
                if suggested_size:
                    print(f"   üíµ Position size sugerido: ${suggested_size:.2f}")
                
                if tp and sl:
                    tp_pct = ((tp - current_price) / current_price) * 100
                    sl_pct = ((current_price - sl) / current_price) * 100
                    print(f"   üéØ TP/SL: ${tp:.4f} (+{tp_pct:.2f}%) / ${sl:.4f} (-{sl_pct:.2f}%)")
                
                # ‚úÖ MEJORA 5: Record throughput health
                if self.throughput_health:
                    self.throughput_health.record_signal('BUY')
                
                # Log ML_DECISION solo aqu√≠, con decisi√≥n final
                self.log_ml_decision(
                    signal_used="enhanced",
                    final_confidence=calibrated_score,
                    effective_threshold=threshold_final,
                    symbol=symbol,
                    trade_decision="buy"
                )
                
                self.save_market_analysis(symbol, current_price, calibrated_score)
                
                return {
                    'symbol': symbol,
                    'price': current_price,
                    'score': calibrated_score,
                    'action': 'BUY',
                    'suggested_size': suggested_size,
                    'tp': tp,
                    'sl': sl,
                    'regime': regime,
                    'atr': atr
                }
            
            # === FALLBACK: M√©todo tradicional si bundle no est√° disponible ===
            else:
                # Calculate score with ML
                score = await self.calculate_score(symbol, current_price, estimated_amount)
                
                # Save market analysis to database for ML training
                self.save_market_analysis(symbol, current_price, score)
                
                # Use effective threshold for decision
                effective_threshold = self.compute_effective_threshold(enhanced=True, symbol=symbol)
                
                if score >= effective_threshold:
                    print(f"üìä {symbol}: Score {score:.3f} - ‚úÖ OPORTUNIDAD")
                    print(f"   üí∞ Precio: ${current_price:,.4f}")
                    
                    return {
                        'symbol': symbol,
                        'price': current_price,
                        'score': score,
                        'action': 'BUY'
                    }
                else:
                    # Decision already logged in "DECISI√ìN FINAL" block above
                    return None
                    
        except Exception as e:
            print(f"‚ùå Error analizando {symbol}: {e}")
            import traceback
            traceback.print_exc()
            return None
    
    async def execute_trade(self, analysis):
        """Execute trade with complete PnL tracking and NOTIONAL error handling"""
        
        symbol = analysis['symbol']
        price = analysis['price']
        score = analysis['score']
        
        # Check symbol tradability (cooldown + daily limit)
        if not self.can_trade_symbol_now(symbol):
            print(f"‚è≠Ô∏è  {symbol}: Cannot trade (cooldown or daily limit reached)")
            return False
        
        # SINCRONIZAR BALANCE REAL ANTES DE CADA TRADE
        await self.sync_balance_with_binance()
        
        # POSITION SIZING DIN√ÅMICO - OPTIMIZADO POR ANALYTICS ENGINE
        # Ajustar tama√±o basado en confianza ML para mejor gesti√≥n de riesgo
        base_trade_amount = self.balance_usdt * self.max_position_percent
        
        # CONSERVATIVE POSITION SIZING - Enhanced risk management
        # Rango ultra-conservador: 0.3 a 0.8 (reducido desde 0.4 a 1.0)
        confidence_multiplier = 0.3 + (score * 0.5)  # M√°s conservador
        
        # Aplicar penalizaci√≥n adicional si confianza < 0.85 (solo posiciones muy seguras)
        if score < 0.85:
            confidence_penalty = 0.7  # Reducir 30% adicional para confianzas medias
            confidence_multiplier *= confidence_penalty
            print(f"üìä Penalizaci√≥n por confianza media ({score:.3f}): {confidence_penalty:.1%}")
        
        # Penalizaci√≥n adicional por racha de p√©rdidas
        if hasattr(self, 'consecutive_losses') and self.consecutive_losses > 0:
            loss_streak_penalty = max(0.5, 1.0 - (self.consecutive_losses * 0.15))
            confidence_multiplier *= loss_streak_penalty
            print(f"üìâ Penalizaci√≥n por racha de p√©rdidas ({self.consecutive_losses}): {loss_streak_penalty:.1%}")
        
        base_trade_amount *= confidence_multiplier
        print(f"üí∞ Position sizing: Base=${self.balance_usdt * self.max_position_percent:.2f}, "
              f"Confianza={score:.3f}, Multiplicador={confidence_multiplier:.2f}, "
              f"Final=${base_trade_amount:.2f}")
        
        # Position sizing por buckets de s√≠mbolos - CONSERVATIVE BUCKETS
        symbol_base = symbol.replace('/USDT', '').upper()
        
        # Define symbol buckets with position size percentages
        stable_symbols = self.config.get('symbol_specific', {}).get('stable_symbols', ['BTC', 'ETH', 'BNB'])
        high_vol_symbols = self.config.get('symbol_specific', {}).get('high_volatility_symbols', ['DOGE', 'PEPE', 'TRUMP'])
        
        if symbol_base in stable_symbols:
            # Stable symbols: 8-10% of balance (reducido desde 12-15%)
            position_percent = 0.09  # 9% average
            base_trade_amount = self.balance_usdt * position_percent
            print(f"üìä Stable symbol {symbol_base}: {position_percent:.1%} position size")
        elif symbol_base in high_vol_symbols:
            # High volatility symbols: 3-5% of balance (reducido desde 5-8%)
            position_percent = 0.04  # 4% average
            base_trade_amount = self.balance_usdt * position_percent
            print(f"üìâ High-vol symbol {symbol_base}: {position_percent:.1%} position size")
        else:
            # Normal symbols: 5-7% of balance (reducido desde 8-10%)
            position_percent = 0.06  # 6% average
            base_trade_amount = self.balance_usdt * position_percent
            print(f"üìà Normal symbol {symbol_base}: {position_percent:.1%} position size")
        
        # Ajuste adicional por PnL diario (reducir si hay p√©rdidas)
        if self.daily_pnl < 0:
            loss_factor = max(0.5, 1 + (self.daily_pnl / self.balance_usdt))  # Reducir si hay p√©rdidas
            base_trade_amount *= loss_factor
            print(f"üìâ Reduciendo posici√≥n por p√©rdidas diarias: factor {loss_factor:.2f}")
        
        # Apply conservative mode position size adjustment
        if self.conservative_mode_state['active']:
            original_amount = base_trade_amount
            _, base_trade_amount = self.apply_conservative_mode_adjustments(0, base_trade_amount)
            reduction_pct = self.conservative_mode_state['position_reduction']
            # Apply debounce to position size reduction alert
            if self.should_send_alert('conservative_mode_position_reduction'):
                print(f"üî¥ CONSERVATIVE_MODE: position_size_reduced=true, "
                      f"original=${original_amount:.2f}, adjusted=${base_trade_amount:.2f}, "
                      f"reduction={reduction_pct:.1%}")
        
        # FASE 2: Aplicar multiplicador din√°mico del analytics
        base_trade_amount *= self.position_multiplier
        if self.position_multiplier != 1.0:
            print(f"üîß Analytics multiplier aplicado: {self.position_multiplier:.2f}x")
        
        base_trade_amount = min(base_trade_amount, 100)  # Max $100 per trade
        base_trade_amount = max(base_trade_amount, 15.0)  # Min $15 per trade (NOTIONAL safety)
        
        # CIRCUIT BREAKER AVANZADO - OPTIMIZADO POR ANALYTICS ENGINE
        # Implementar protecci√≥n contra drawdown excesivo (>8%)
        daily_loss_percent = (self.daily_pnl / self.balance_usdt) * 100 if self.balance_usdt > 0 else 0
        
        # Circuit breaker por p√©rdida diaria excesiva (5% l√≠mite)
        if daily_loss_percent < -5.0:
            print(f"üö® CIRCUIT BREAKER ACTIVADO: P√©rdida diaria {daily_loss_percent:.2f}% > 5%")
            print(f"üîÑ Cerrando todas las posiciones por protecci√≥n de capital...")
            await self.emergency_close_all_positions("Daily loss limit exceeded (5%)")
            # Activar modo conservador por el resto del d√≠a
            self.conservative_mode_state['active'] = True
            self.conservative_mode_state['position_reduction'] = 0.8  # Reducir 80% las posiciones
            return False
        
        # Reducci√≥n progresiva de posiciones por p√©rdidas moderadas (2-5%)
        elif daily_loss_percent < -2.0:
            progressive_reduction = min(0.5, abs(daily_loss_percent) / 10)  # Hasta 50% reducci√≥n
            base_trade_amount *= (1 - progressive_reduction)
            print(f"‚ö†Ô∏è Reducci√≥n progresiva por p√©rdidas: {progressive_reduction:.1%} (PnL diario: {daily_loss_percent:.2f}%)")
        
        # VERIFICACI√ìN CR√çTICA: Si no hay suficiente balance, cerrar posiciones
        if self.balance_usdt < base_trade_amount:
            print(f"‚ö†Ô∏è  Balance insuficiente: ${self.balance_usdt:.2f} < ${base_trade_amount:.2f}")
            print(f"üîÑ Iniciando cierre de posiciones por falta de capital...")
            await self.emergency_close_all_positions("Insufficient balance for minimum trade")
            return False
        
        quantity = base_trade_amount / price
        
        # ============================================================================
        # RISK MANAGEMENT INTEGRATION - Fee Drag Control & Exposure Caps
        # ============================================================================
        if RISK_MANAGEMENT_AVAILABLE:
            # 1. Fee Drag Control - Check minimum notional
            class Signal:
                def __init__(self, symbol, price, setup_type='scalp'):
                    self.symbol = symbol
                    self.price = price
                    self.setup_type = setup_type
            
            signal = Signal(symbol, price, 'scalp')
            
            def existing_size_func(sig, acc):
                return quantity
            
            checked_quantity = compute_position_size(signal, None, existing_size_func)
            
            if checked_quantity == 0:
                print(f"‚è≠Ô∏è  {symbol}: Trade skipped - below minimum notional (fee drag control)")
                return False
            
            quantity = checked_quantity
            base_trade_amount = quantity * price
            
            # 2. Exposure Management - Check cluster/symbol caps
            portfolio = PortfolioHelper(self)
            breach, metadata = will_breach_caps(symbol, base_trade_amount, portfolio)
            
            if breach:
                print(f"‚è≠Ô∏è  {symbol}: Trade skipped - exposure cap breach")
                print(f"   Cluster: {metadata.get('cluster')}")
                if 'cluster' in metadata and isinstance(metadata['cluster'], dict):
                    cluster_info = metadata['cluster']
                    print(f"   Cluster exposure: {cluster_info.get('current', 0):.1%} ‚Üí {cluster_info.get('new', 0):.1%} (limit: {cluster_info.get('limit', 0):.1%})")
                if 'symbol' in metadata and isinstance(metadata['symbol'], dict):
                    symbol_info = metadata['symbol']
                    print(f"   Symbol exposure: {symbol_info.get('current', 0):.1%} ‚Üí {symbol_info.get('new', 0):.1%} (limit: {symbol_info.get('limit', 0):.1%})")
                return False
        
        # TAKE PROFIT DIN√ÅMICO OPTIMIZADO - Basado en confianza ML para mejor Sharpe ratio
        base_take_profit = self.memecoin_take_profit if any(mem in symbol for mem in self.high_volatility_symbols) else self.stable_take_profit
        
        # Ajustar take profit basado en confianza ML (mayor confianza = mayor take profit)
        confidence_tp_multiplier = 0.8 + (score * 0.6)  # Rango: 0.8 a 1.4
        take_profit_pct = base_take_profit * confidence_tp_multiplier
        
        # L√≠mites de take profit para gesti√≥n de riesgo
        if any(mem in symbol for mem in self.high_volatility_symbols):
            take_profit_pct = max(1.8, min(take_profit_pct, 4.0))  # 1.8% - 4.0% para alta volatilidad
            stop_loss_pct = max(self.stop_loss_percent, 2.5)  # 2.5% para alta volatilidad
        else:
            take_profit_pct = max(1.2, min(take_profit_pct, 2.8))  # 1.2% - 2.8% para s√≠mbolos estables
            stop_loss_pct = max(self.stop_loss_percent, 2.0)  # 2.0% m√≠nimo
        
        print(f"üìà Take Profit din√°mico: Base={base_take_profit:.1f}%, "
              f"Confianza={score:.3f}, Multiplicador={confidence_tp_multiplier:.2f}, "
              f"Final={take_profit_pct:.2f}%")
        
        # Calculate target prices
        take_profit_price = price * (1 + take_profit_pct / 100)
        stop_loss_price = price * (1 - stop_loss_pct / 100)
        
        # ============================================================================
        # RISK MANAGEMENT V2 INTEGRATION - Enhanced Pre-Trade Validation
        # ============================================================================
        if RISK_MANAGEMENT_V2_AVAILABLE and self.portfolio_v2 is not None:
            try:
                # Create orderbook snapshot
                if self.simulation_mode:
                    # Mock orderbook for simulation
                    orderbook = OrderbookSnapshot(
                        best_bid=price * 0.9997,
                        best_ask=price * 1.0003,
                        bid_depth=base_trade_amount * 5,
                        ask_depth=base_trade_amount * 5
                    )
                else:
                    # Get real orderbook (simplified for now)
                    orderbook = OrderbookSnapshot(
                        best_bid=price * 0.9998,
                        best_ask=price * 1.0002,
                        bid_depth=base_trade_amount * 3,
                        ask_depth=base_trade_amount * 3
                    )
                
                # Get ML confidence from analysis
                ml_confidence = score  # Use the score as ML confidence
                
                # Run V2 pre-trade validation
                result = pre_trade_check_v2(
                    symbol=symbol,
                    notional_calc=base_trade_amount,
                    ml_confidence=ml_confidence,
                    orderbook=orderbook,
                    portfolio=self.portfolio_v2,
                    equity_usd=self.balance_usdt,
                    has_bnb=True
                )
                
                # Log V2 result
                log_pre_trade_result(result, symbol)
                
                # Handle V2 result
                if not result.approved:
                    print(f"‚è≠Ô∏è  {symbol}: Trade rejected by V2 - {result.reason}")
                    return False
                
                # Use V2 adjusted size
                if result.adjusted_size != base_trade_amount:
                    print(f"üìè {symbol}: Size adjusted by V2: ${base_trade_amount:.2f} ‚Üí ${result.adjusted_size:.2f}")
                    base_trade_amount = result.adjusted_size
                    quantity = base_trade_amount / price
                
                # Try batching (V2 feature)
                enqueued = execute_with_batching(
                    symbol=symbol,
                    side="BUY",
                    notional=base_trade_amount,
                    price=price,
                    tif="IOC"
                )
                
                if enqueued:
                    print(f"üì¶ {symbol}: Order enqueued for batching")
                    # Update portfolio tracker
                    self.portfolio_v2.add_position(symbol, base_trade_amount)
                    return True
                
                print(f"‚úÖ {symbol}: V2 validation passed, proceeding with immediate execution")
                
            except Exception as e:
                print(f"‚ö†Ô∏è  V2 validation error for {symbol}: {e}")
                print(f"   Falling back to V1 logic...")
        
        print(f"\nüü¢ EJECUTANDO {'COMPRA REAL' if not self.simulation_mode else 'COMPRA SIMULADA'}")
        print(f"üìä S√≠mbolo: {symbol}")
        print(f"üí∞ Cantidad: ${base_trade_amount:.2f}")
        print(f"üí± Precio: ${price:,.4f}")
        print(f"üß† Score: {score:.3f}")
        print(f"üéØ Take Profit: ${take_profit_price:,.4f} (+{take_profit_pct:.2f}%)")
        print(f"üõë Stop Loss: ${stop_loss_price:,.4f} (-{stop_loss_pct:.2f}%)")
        
        # Generate unique trade ID
        trade_id = f"{symbol.replace('/', '')}_{int(datetime.now().timestamp())}"
        
        try:
            if not self.simulation_mode:
                # Execute real order with NOTIONAL error handling
                try:
                    order = self.exchange.create_market_buy_order(symbol, quantity)
                    order_id = order['id']
                    actual_quantity = order['filled']
                    actual_price = order['average'] if order['average'] else price
                    fees = order.get('fee', {}).get('cost', 0)
                    
                    # MEJORA: Verificar balance real despu√©s de la compra
                    try:
                        import time
                        time.sleep(1)  # Esperar a que se actualice el balance
                        balance = self.exchange.fetch_balance()
                        base_currency = symbol.split('/')[0]
                        real_balance = balance[base_currency]['free']
                        
                        if real_balance > 0:
                            actual_quantity = real_balance  # Usar balance real
                            print(f"üîç Balance real verificado: {real_balance}")
                        
                    except Exception as balance_check_error:
                        print(f"‚ö†Ô∏è No se pudo verificar balance real: {balance_check_error}")
                        # Continuar con actual_quantity del order
                        
                except Exception as order_error:
                    # USAR ENHANCED ERROR HANDLER SI EST√Å DISPONIBLE
                    if self.error_handler:
                        error_info = await self.error_handler.handle_trading_error(
                            order_error, symbol, base_trade_amount
                        )
                        return error_info.get('success', False)
                    else:
                        # MANEJO B√ÅSICO DEL ERROR NOTIONAL
                        if "NOTIONAL" in str(order_error) or "notional" in str(order_error).lower():
                            print(f"‚ùå ERROR NOTIONAL detectado: {order_error}")
                            print(f"üí∞ Balance actual: ${self.balance_usdt:.2f}")
                            print(f"üîÑ Cerrando todas las posiciones - No hay suficiente capital para operar")
                            await self.emergency_close_all_positions("NOTIONAL filter failure - insufficient funds")
                            return False
                        else:
                            # Re-raise other errors
                            raise order_error
                    
            else:
                # Simulate order execution
                order_id = f"SIM_{trade_id}"
                actual_quantity = quantity
                actual_price = price * random.uniform(0.999, 1.001)  # Small slippage
                fees = base_trade_amount * 0.001  # 0.1% fee simulation
            
            # Store trade in database with complete tracking info
            if self.trade_db:
                trade_data = {
                    'id': trade_id,
                    'timestamp': datetime.now().isoformat(),
                    'symbol': symbol,
                    'side': 'buy',
                    'amount': actual_quantity,
                    'entry_price': actual_price,
                    'order_id': order_id,
                    'status': 'open',
                    'filled_amount': actual_quantity,
                    'avg_fill_price': actual_price,
                    'fees': fees,
                    'ml_confidence': score,
                    'ml_predicted_success': 1 if score > self.compute_effective_threshold(enhanced=ENHANCED_ML_AVAILABLE, symbol=symbol) else 0,
                    'ml_model_version': 'v2.1_optimized',
                    'final_score': score,
                    'confidence_threshold': self.compute_effective_threshold(enhanced=ENHANCED_ML_AVAILABLE, symbol=symbol),
                    'position_size_percent': (base_trade_amount / self.balance_usdt) * 100,
                    'stop_loss_price': stop_loss_price,
                    'take_profit_price': take_profit_price,
                    'metadata': json.dumps({
                        'take_profit_pct': take_profit_pct,
                        'stop_loss_pct': stop_loss_pct,
                        'simulation_mode': self.simulation_mode
                    }),
                    'created_at': datetime.now().isoformat()
                }
                
                self.trade_db.store_trade(trade_data)
                print(f"‚úÖ Trade guardado en DB: {trade_id}")
                
                # Incrementar contador de analytics
                if self.analytics_engine:
                    self.analytics_counter += 1
            
            # Add to positions for monitoring
            self.positions[symbol] = {
                'trade_id': trade_id,
                'quantity': actual_quantity,
                'entry_price': actual_price,
                'entry_time': datetime.now(),
                'take_profit_price': take_profit_price,
                'stop_loss_price': stop_loss_price,
                'ml_confidence': score,
                'trade_amount': base_trade_amount,
                'fees': fees
            }
            
            # Update balance
            self.balance_usdt -= (base_trade_amount + fees)
            self.trades_today += 1
            
            # Reset error counters en caso de trade exitoso
            if self.error_handler:
                self.error_handler.reset_error_counters()
            
            print(f"‚úÖ Trade ejecutado exitosamente")
            print(f"üí∞ Balance restante: ${self.balance_usdt:.2f}")
            print(f"üìà Trades hoy: {self.trades_today}")
            
            return True
            
        except Exception as e:
            # USAR ENHANCED ERROR HANDLER SI EST√Å DISPONIBLE
            if self.error_handler:
                error_info = await self.error_handler.handle_trading_error(e, symbol, base_trade_amount)
                return error_info.get('success', False)
            else:
                print(f"‚ùå Error ejecutando trade: {e}")
                return False
    
    def get_open_positions_count(self) -> int:
        """Get count of open positions for ML predictor position tracker"""
        try:
            return len(self.positions) if self.positions else 0
        except Exception as e:
            print(f"üîç ML_TRACE: position_count_error='{str(e)}', returning_zero=true")
            return 0
    
    def get_live_market_data(self, symbol: str) -> Dict[str, Any]:
        """
        Endpoint para exponer datos de mercado en tiempo real al analytics engine
        
        Returns:
            Dict con price, volume, RSI y otros indicadores t√©cnicos
        """
        try:
            # Obtener datos actuales del exchange
            if self.simulation_mode:
                # En modo simulaci√≥n, generar datos simulados
                import random
                base_price = 50000 if 'BTC' in symbol else 3000 if 'ETH' in symbol else 100
                return {
                    'symbol': symbol,
                    'price': base_price * (1 + random.uniform(-0.02, 0.02)),
                    'volume': random.uniform(1000000, 10000000),
                    'rsi': random.uniform(30, 70),
                    'timestamp': datetime.now(timezone.utc).isoformat(),
                    'bid': base_price * 0.999,
                    'ask': base_price * 1.001,
                    'high_24h': base_price * 1.05,
                    'low_24h': base_price * 0.95,
                    'change_24h': random.uniform(-5, 5)
                }
            else:
                ticker = self.exchange.fetch_ticker(symbol)
                
                # Calcular RSI si tenemos datos hist√≥ricos
                rsi = self._calculate_rsi(symbol) if hasattr(self, '_calculate_rsi') else 50.0
                
                return {
                    'symbol': symbol,
                    'price': ticker['last'],
                    'volume': ticker['quoteVolume'],
                    'rsi': rsi,
                    'timestamp': datetime.now(timezone.utc).isoformat(),
                    'bid': ticker['bid'],
                    'ask': ticker['ask'],
                    'high_24h': ticker['high'],
                    'low_24h': ticker['low'],
                    'change_24h': ticker['percentage']
                }
        except Exception as e:
            print(f"‚ùå Error obteniendo datos de mercado para {symbol}: {e}")
            return None
    
    def get_bot_feed_for_analytics(self) -> Dict[str, Any]:
        """
        Feed completo del bot para el analytics engine
        Incluye posiciones, balance, y datos de mercado
        """
        try:
            # Convertir posiciones a formato JSON-serializable
            serializable_positions = {}
            for symbol, pos in self.positions.items():
                serializable_positions[symbol] = {
                    **pos,
                    'entry_time': pos['entry_time'].isoformat() if isinstance(pos.get('entry_time'), datetime) else pos.get('entry_time')
                }
            
            return {
                'timestamp': datetime.now(timezone.utc).isoformat(),
                'balance_usdt': self.balance_usdt,
                'positions': serializable_positions,
                'daily_pnl': self.daily_pnl,
                'trades_today': self.trades_today,
                'market_data': {
                    symbol: self.get_live_market_data(symbol) 
                    for symbol in self.symbols
                },
                'ml_status': {
                    'enabled': self.ml_enabled,
                    'last_retrain': self.last_retrain_time.isoformat() if self.last_retrain_time else None,
                    'predictions_count': len(self.ml_predictions) if hasattr(self, 'ml_predictions') else 0
                }
            }
        except Exception as e:
            print(f"‚ùå Error generando feed para analytics: {e}")
            return None
    
    async def monitor_positions(self):
        """Monitor open positions and execute stop-loss/take-profit"""
        if not self.positions:
            return
        
        positions_to_close = []
        
        for symbol, position in self.positions.items():
            try:
                # üîß PATCH v1.5 - Fix #1: Validate position before accessing
                if position is None:
                    print(f"‚ö†Ô∏è Position for {symbol} is None, skipping")
                    continue
                
                if not isinstance(position, dict):
                    print(f"‚ö†Ô∏è Position for {symbol} is not a dict, skipping")
                    continue
                
                # Validate required fields
                required_fields = ['entry_price', 'entry_time', 'ml_confidence', 'quantity']
                if not all(field in position for field in required_fields):
                    print(f"‚ö†Ô∏è Position for {symbol} missing required fields, skipping")
                    continue
                
                # Get current price
                if self.simulation_mode:
                    # Simulate realistic price movement based on ML confidence
                    entry_price = position['entry_price']
                    time_elapsed = (datetime.now() - position['entry_time']).total_seconds() / 60
                    ml_conf = position['ml_confidence']
                    
                    # Higher confidence = higher probability of positive movement
                    if ml_conf > 0.8:
                        trend_bias = 0.0015  # Strong positive bias
                    elif ml_conf > 0.7:
                        trend_bias = 0.0008  # Moderate positive bias
                    else:
                        trend_bias = -0.0002  # Slight negative bias
                    
                    # Add volatility
                    volatility = 0.002 * (1 + time_elapsed / 60)
                    random_movement = random.gauss(trend_bias, volatility)
                    current_price = entry_price * (1 + random_movement)
                else:
                    ticker = self.exchange.fetch_ticker(symbol)
                    current_price = ticker['last']
                
                # Calculate current PnL
                quantity = position['quantity']
                entry_price = position['entry_price']
                pnl = (current_price - entry_price) * quantity
                pnl_percent = ((current_price - entry_price) / entry_price) * 100
                
                # Check stop-loss and take-profit
                should_close = False
                close_reason = ""
                
                take_profit_price = position.get('take_profit_price')
                stop_loss_price = position.get('stop_loss_price')
                
                if take_profit_price and current_price >= take_profit_price:
                    should_close = True
                    close_reason = "TAKE_PROFIT"
                elif stop_loss_price and current_price <= stop_loss_price:
                    should_close = True
                    close_reason = "STOP_LOSS"
                
                # ============================================================================
                # RISK MANAGEMENT INTEGRATION - Time Exits & MAE Hardcut
                # ============================================================================
                if RISK_MANAGEMENT_AVAILABLE:
                    # Calculate time elapsed in minutes
                    minutes_open = (datetime.now() - position['entry_time']).total_seconds() / 60
                    
                    # Add symbol to position dict for risk management functions
                    position_with_symbol = {**position, 'symbol': symbol}
                    
                    # 1. Check MAE Hardcut (early adverse selection)
                    bars_since_entry = int(minutes_open)  # Approximate bars as minutes
                    should_cut, cut_meta = check_mae_hardcut(position_with_symbol, current_price, bars_since_entry)
                    
                    if should_cut:
                        should_close = True
                        close_reason = "MAE_HARDCUT"
                        print(f"üî™ {symbol}: MAE Hardcut triggered - {cut_meta}")
                    
                    # 2. Check Time-Based Exit (stagnation)
                    if not should_close:
                        should_exit, exit_meta = check_time_exit(position_with_symbol, minutes_open, current_price)
                        
                        if should_exit:
                            should_close = True
                            close_reason = "TIME_EXIT_STAGNATION"
                            print(f"‚è∞ {symbol}: Time exit triggered - {exit_meta}")
                
                # ============================================================================
                # ‚úÖ MEJORA 1: TRAILING STOP (solo HIGH regime)
                # ============================================================================
                if self.trailing_stop_manager and not should_close:
                    try:
                        # Detect regime from ML confidence
                        ml_conf = position.get('ml_confidence', 0.70)
                        if ml_conf < 0.70:
                            regime = "LOW"
                        elif ml_conf < 0.80:
                            regime = "MID"
                        else:
                            regime = "HIGH"
                        
                        # Get ATR (simplified - use 1% of price as fallback)
                        atr = position.get('atr_at_entry', current_price * 0.01)
                        
                        # Check trailing stop
                        should_exit_trail, exit_price, trail_reason = self.trailing_stop_manager.check_exit(
                            symbol, regime, entry_price, current_price, atr
                        )
                        
                        if should_exit_trail:
                            should_close = True
                            close_reason = "TRAILING_STOP_HIGH"
                            print(f"üìâ {symbol}: {trail_reason}")
                    
                    except Exception as e:
                        print(f"‚ö†Ô∏è  Trailing stop error for {symbol}: {e}")
                
                # ============================================================================
                # RISK MANAGEMENT V2 INTEGRATION - Enhanced Position Monitoring
                # ============================================================================
                if RISK_MANAGEMENT_V2_AVAILABLE and not should_close:
                    try:
                        # Detect regime from ML confidence
                        ml_conf = position.get('ml_confidence', 0.70)
                        if ml_conf < 0.70:
                            regime = "LOW"
                        elif ml_conf < 0.80:
                            regime = "MID"
                        else:
                            regime = "HIGH"
                        
                        # Monitor with V2
                        decision = monitor_position_v2(
                            position=position_with_symbol,
                            current_price=current_price,
                            regime=regime,
                            symbol=symbol
                        )
                        
                        # Log V2 decision
                        log_exit_decision(decision, symbol, position)
                        
                        # Handle V2 exit decision
                        if decision.should_exit:
                            should_close = True
                            close_reason = f"V2_{decision.exit_type}"
                            print(f"üîî {symbol}: V2 exit triggered - {decision.reason}")
                    
                    except Exception as e:
                        print(f"‚ö†Ô∏è  V2 monitoring error for {symbol}: {e}")
                
                else:
                    # Fallback: Original time-based exit (after 2 hours)
                    time_elapsed = (datetime.now() - position['entry_time']).total_seconds() / 3600
                    if time_elapsed > 2 and abs(pnl_percent) < 0.5:
                        should_close = True
                        close_reason = "TIME_EXIT"
                
                # V3: Registrar outcome en enhanced policy para cooldown espec√≠fico
                if should_close and hasattr(self, 'enhanced_policy') and self.enhanced_policy:
                    outcome_map = {
                        'TAKE_PROFIT': 'take_profit',
                        'STOP_LOSS': 'stop_loss',
                        'TIME_EXIT': 'timeout'
                    }
                    outcome = outcome_map.get(close_reason, 'timeout')
                    self.enhanced_policy.record_trade_outcome(symbol, outcome)
                
                if should_close:
                    positions_to_close.append((symbol, position, current_price, close_reason, pnl, pnl_percent))
                else:
                    print(f"üìä {symbol}: ${current_price:,.4f} | PnL: {pnl_percent:+.2f}% | ML: {position['ml_confidence']:.3f}")
                    
            except Exception as e:
                print(f"‚ùå Error monitoreando {symbol}: {e}")
        
        # Close positions that hit targets
        for symbol, position, exit_price, reason, pnl, pnl_percent in positions_to_close:
            await self.close_position(symbol, position, exit_price, reason, pnl, pnl_percent)
    
    async def close_position(self, symbol, position, exit_price, reason, pnl, pnl_percent):
        """Close position and update database with complete PnL tracking"""
        
        # üîß PATCH v1.5 - Fix #1: Validate position before processing
        if position is None:
            print(f"‚ö†Ô∏è Cannot close position for {symbol}: position is None")
            return
        
        # Ensure position is a dict (handle both dict and object types)
        if not isinstance(position, dict):
            print(f"‚ö†Ô∏è Position for {symbol} is not a dict, attempting conversion")
            if hasattr(position, '__dict__'):
                position = position.__dict__
            else:
                print(f"‚ùå Cannot convert position to dict for {symbol}")
                return
        
        # Validate required fields
        required_fields = ['quantity', 'entry_price', 'trade_id', 'entry_time', 'fees', 'trade_amount', 'ml_confidence']
        missing_fields = [field for field in required_fields if field not in position]
        if missing_fields:
            print(f"‚ö†Ô∏è Position for {symbol} missing required fields: {missing_fields}")
            return
        
        # Apply debounce to position closing alert
        if self.should_send_alert(f'position_closing_{symbol}'):
            print(f"\nüî¥ CERRANDO POSICI√ìN: {symbol}")
            print(f"üìä Raz√≥n: {reason}")
            print(f"üí∞ PnL: {pnl:+.2f} USDT ({pnl_percent:+.2f}%)")
            print(f"üí± Precio salida: ${exit_price:,.4f}")
        
        try:
            quantity = position['quantity']
            
            if not self.simulation_mode:
                # SOLUCI√ìN ROBUSTA: Obtener balance real de Binance
                try:
                    balance = self.exchange.fetch_balance()
                    base_currency = symbol.split('/')[0]  # DOGE de DOGE/USDT
                    actual_quantity = balance[base_currency]['free']
                    
                    print(f"üîç Balance almacenado: {quantity}")
                    print(f"üîç Balance real Binance: {actual_quantity}")
                    
                    if actual_quantity > 0:
                        # Usar balance real con margen de seguridad (99.9%)
                        safe_quantity = min(actual_quantity, quantity) * 0.999
                        
                        # 1. Verificar cantidad m√≠nima seg√∫n el s√≠mbolo
                        min_quantity = self._get_minimum_quantity(symbol, safe_quantity)
                        
                        # 2. Verificar NOTIONAL m√≠nimo ($5 USD)
                        notional_ok, notional_value = await self._check_notional_minimum(symbol, safe_quantity, exit_price)
                        
                        if safe_quantity >= min_quantity and notional_ok:
                            # ‚úÖ Cantidad y NOTIONAL suficientes - ejecutar venta normal
                            order = self.exchange.create_market_sell_order(symbol, safe_quantity)
                            quantity = safe_quantity  # Actualizar para c√°lculos
                            print(f"‚úÖ Orden ejecutada con cantidad segura: {safe_quantity}")
                            print(f"‚úÖ Valor NOTIONAL: ${notional_value:.2f}")
                        else:
                            # ‚ùå Cantidad o NOTIONAL insuficientes
                            if safe_quantity < min_quantity:
                                print(f"‚ùå Cantidad {safe_quantity:.8f} < m√≠nimo {min_quantity:.8f}")
                            if not notional_ok:
                                print(f"‚ùå Valor NOTIONAL ${notional_value:.2f} < $5.00 m√≠nimo")
                            
                            print(f"üîÑ POSICI√ìN PEQUE√ëA - Marcando como cerrada sin venta")
                            print(f"üí° Binance no permite vender posiciones < $5 USD")
                            
                            # Marcar como cerrada sin ejecutar venta real
                            order = {
                                'id': f'NOTIONAL_SKIP_{position["trade_id"]}', 
                                'average': exit_price,
                                'filled': safe_quantity,
                                'fee': {'cost': 0}
                            }
                            quantity = safe_quantity
                            
                            # Actualizar balance simulando la venta (para tracking)
                            simulated_proceeds = safe_quantity * exit_price
                            print(f"üí∞ Simulando recuperaci√≥n: ${simulated_proceeds:.2f} USDT")
                    else:
                        print(f"‚ùå No hay balance disponible para {symbol}")
                        return
                        
                except Exception as balance_error:
                    print(f"‚ö†Ô∏è Error obteniendo balance, intentando con cantidad almacenada: {balance_error}")
                    # Fallback: intentar con cantidad original
                    order = self.exchange.create_market_sell_order(symbol, quantity)
                
                exit_order_id = order['id']
                actual_exit_price = order['average'] if order['average'] else exit_price
                exit_fees = order.get('fee', {}).get('cost', 0)
            else:
                # Simulate sell order
                exit_order_id = f"SIM_EXIT_{position['trade_id']}"
                actual_exit_price = exit_price * random.uniform(0.999, 1.001)
                exit_fees = (quantity * actual_exit_price) * 0.001
            
            # Calculate final PnL including fees
            gross_pnl = (actual_exit_price - position['entry_price']) * quantity
            net_pnl = gross_pnl - position['fees'] - exit_fees
            net_pnl_percent = (net_pnl / position['trade_amount']) * 100
            
            # Calculate trade duration
            duration_minutes = (datetime.now() - position['entry_time']).total_seconds() / 60
            
            # Update trade in database
            if self.trade_db:
                trade_update = {
                    'exit_timestamp': datetime.now().isoformat(),
                    'exit_price': actual_exit_price,
                    'exit_order_id': exit_order_id,
                    'status': 'completed',
                    'pnl': net_pnl,
                    'pnl_percent': net_pnl_percent,
                    'duration_minutes': int(duration_minutes),
                    'fees': position['fees'] + exit_fees
                }
                
                self.trade_db.update_trade(position['trade_id'], trade_update)
                print(f"‚úÖ Trade actualizado en DB: {position['trade_id']}")
                
                # Store ML prediction result for accuracy tracking
                effective_threshold = self.compute_effective_threshold(enhanced=True)
                ml_prediction_result = {
                    'trade_id': position['trade_id'],
                    'ml_confidence': position['ml_confidence'],
                    'predicted_success': 1 if position['ml_confidence'] > effective_threshold else 0,
                    'actual_success': 1 if net_pnl_percent > 0 else 0,
                    'pnl_percent': net_pnl_percent,
                    'close_reason': reason,
                    'timestamp': datetime.now().isoformat()
                }
                
                self.ml_predictions.append(ml_prediction_result)
                
                # Keep only last N predictions
                if len(self.ml_predictions) > self.ml_accuracy_window:
                    self.ml_predictions = self.ml_predictions[-self.ml_accuracy_window:]
            
            # Update ML engine with trade result
            if self.ml_enabled and self.ml_engine:
                try:
                    # üîß PATCH v1.5 - Fix #1: Safe extraction of position data
                    # Import TradeRecord and related classes
                    from src.ml.data_models import TradeRecord, TradeSide, TradeStatus
                    
                    # Safely extract values with defaults
                    def safe_get(obj, key, default=None):
                        """Safely get value from dict or object"""
                        if isinstance(obj, dict):
                            return obj.get(key, default)
                        else:
                            return getattr(obj, key, default)
                    
                    # Create TradeRecord object for ML learning
                    trade_record = TradeRecord(
                        id=safe_get(position, 'trade_id', f'unknown_{symbol}'),
                        timestamp=safe_get(position, 'entry_time', datetime.now()),
                        symbol=symbol,
                        side=TradeSide.BUY,  # Assuming buy trades for now
                        amount=quantity,
                        entry_price=safe_get(position, 'entry_price', 0),
                        order_id=safe_get(position, 'order_id', safe_get(position, 'trade_id', 'unknown')),
                        status=TradeStatus.FILLED,
                        filled_amount=quantity,
                        avg_fill_price=safe_get(position, 'entry_price', 0),
                        fees=safe_get(position, 'fees', 0),
                        exit_timestamp=datetime.now(),
                        exit_price=actual_exit_price,
                        exit_order_id=exit_order_id,
                        pnl=net_pnl,
                        pnl_percent=net_pnl_percent,
                        duration_minutes=int(duration_minutes),
                        ml_confidence=safe_get(position, 'ml_confidence', 0.5),
                        final_score=safe_get(position, 'ml_confidence', 0.5)
                    )
                    
                    # Update ML engine asynchronously
                    await self.ml_engine.update_with_trade_result(trade_record)
                    print(f"‚úÖ ML actualizado con resultado del trade")
                    
                except Exception as e:
                    print(f"‚ö†Ô∏è  Error actualizando ML: {e}")
                    import traceback
                    print(f"   Detalles: {traceback.format_exc()}")
            
            # Update balance and daily PnL
            self.balance_usdt += (quantity * actual_exit_price) - exit_fees
            self.daily_pnl += net_pnl
            
            # Track consecutive wins/losses for position sizing
            if net_pnl > 0:
                self.consecutive_wins += 1
                self.consecutive_losses = 0  # Reset loss streak
                print(f"üéØ Racha de victorias: {self.consecutive_wins}")
            else:
                self.consecutive_losses += 1
                self.consecutive_wins = 0  # Reset win streak
                print(f"üìâ Racha de p√©rdidas: {self.consecutive_losses}")
            
            # Update Symbol Bandit with trade result
            if RISK_MANAGEMENT_AVAILABLE:
                try:
                    is_win = net_pnl > 0
                    bandit.update(symbol, is_win)
                    if not is_win and self.consecutive_losses >= 3:
                        print(f"üé∞ Bandit updated: {symbol} loss streak = {self.consecutive_losses}")
                except Exception as e:
                    print(f"‚ö†Ô∏è  Bandit update error: {e}")
            
            # ============================================================================
            # RISK MANAGEMENT V2 INTEGRATION - Enhanced Bandit Update
            # ============================================================================
            if RISK_MANAGEMENT_V2_AVAILABLE:
                try:
                    # Get symbol metrics (simplified for now)
                    pf_symbol = 1.5 if net_pnl > 0 else 0.8  # Placeholder
                    wr_symbol = 0.55 if net_pnl > 0 else 0.45  # Placeholder
                    
                    # Update bandit with V2 penalties
                    bandit_result = update_bandit_on_close(
                        symbol=symbol,
                        net_pnl=net_pnl,
                        loss_streak=self.consecutive_losses,
                        pf_symbol=pf_symbol,
                        wr_symbol=wr_symbol
                    )
                    
                    # Handle blacklist
                    if bandit_result.get('is_blacklisted', False):
                        print(f"üö´ {symbol} is now BLACKLISTED for 24h (V2)")
                        # Add to blacklist (you may want to implement this)
                        # self.blacklisted_symbols[symbol] = time.time() + (24 * 3600)
                    
                    # Update portfolio tracker
                    if self.portfolio_v2:
                        self.portfolio_v2.remove_position(symbol)
                
                except Exception as e:
                    print(f"‚ö†Ô∏è  V2 bandit update error: {e}")
            
            # CIRCUIT BREAKER - OPTIMIZADO POR ANALYTICS ENGINE
            # Activar modo de emergencia si p√©rdida diaria > 5% para reducir drawdown
            daily_loss_percent = (self.daily_pnl / self.balance_usdt) * 100 if self.balance_usdt > 0 else 0
            if daily_loss_percent < -5.0 and not self.emergency_mode:  # Si p√©rdida diaria > 5%
                print(f"üö® CIRCUIT BREAKER ACTIVADO: P√©rdida diaria {daily_loss_percent:.1f}% > 5%")
                print(f"üõë Cerrando todas las posiciones por protecci√≥n de capital")
                await self.emergency_close_all_positions("Circuit breaker: Daily loss limit exceeded")
                # Pausar trading por 1 hora
                self.emergency_mode = True
                self.emergency_start_time = datetime.now()
                print(f"‚è∏Ô∏è  Trading pausado por 1 hora para protecci√≥n")
            
            # Remove from positions
            del self.positions[symbol]
            
            # Add to trade history
            self.trade_history.append({
                'symbol': symbol,
                'entry_price': position['entry_price'],
                'exit_price': actual_exit_price,
                'pnl': net_pnl,
                'pnl_percent': net_pnl_percent,
                'duration_minutes': duration_minutes,
                'reason': reason,
                'ml_confidence': position['ml_confidence'],
                'timestamp': datetime.now()
            })
            
            print(f"‚úÖ Posici√≥n cerrada exitosamente")
            print(f"üí∞ Balance actualizado: ${self.balance_usdt:.2f}")
            print(f"üìà PnL diario: {self.daily_pnl:+.2f} USDT")
            
            # Print ML accuracy update
            self.print_ml_accuracy_update()
            
            # Update Symbol Memory
            await self.update_symbol_memory_on_close(symbol, {
                'pnl': net_pnl,
                'pnl_pct': net_pnl_percent,
                'win': net_pnl > 0,
                'timestamp': datetime.now().timestamp(),
                'exit_reason': reason,
                'mae': position.get('mae', 0),
                'mfe': position.get('mfe', 0)
            })
            
            # Increment daily count for symbol
            if SYMBOL_SCORING_AVAILABLE and self.symbol_memory:
                self.symbol_memory.increment_daily_count(symbol)
            
        except Exception as e:
            print(f"‚ùå Error cerrando posici√≥n {symbol}: {e}")
            
            # Debug adicional para problemas de balance
            if not self.simulation_mode and "insufficient balance" in str(e).lower():
                try:
                    balance = self.exchange.fetch_balance()
                    base_currency = symbol.split('/')[0]
                    print(f"üîç DEBUG - Balance total: {balance[base_currency]['total']}")
                    print(f"üîç DEBUG - Balance libre: {balance[base_currency]['free']}")
                    print(f"üîç DEBUG - Balance usado: {balance[base_currency]['used']}")
                    print(f"üîç DEBUG - Cantidad almacenada: {position['quantity']}")
                except Exception as debug_error:
                    print(f"üîç No se pudo obtener balance para debug: {debug_error}")
    
    def _get_minimum_quantity(self, symbol, quantity):
        """Obtener cantidad m√≠nima para un s√≠mbolo (solo cantidad, no valor)"""
        try:
            if self.simulation_mode:
                return 0.000001  # M√≠nimo simulado muy bajo
            
            # Cantidades m√≠nimas conocidas para s√≠mbolos comunes
            min_quantities = {
                'BTC/USDT': 0.00001,
                'ETH/USDT': 0.0001,
                'BNB/USDT': 0.001,
                'DOGE/USDT': 1.0,
                'ADA/USDT': 1.0,
                'SOL/USDT': 0.001,
                'LINK/USDT': 0.01,
                'DOT/USDT': 0.1,
                'AVAX/USDT': 0.01,
                'MATIC/USDT': 1.0,
                'UNI/USDT': 0.01,
                'LTC/USDT': 0.001,
                'XRP/USDT': 1.0,
                'TRX/USDT': 10.0,
                'USDC/USDT': 1.0,
                'PAXG/USDT': 0.0001,  # Oro - cantidad m√≠nima alta
                'ATOM/USDT': 0.1,
                'ALGO/USDT': 1.0
            }
            
            return min_quantities.get(symbol, 0.001)  # Default 0.001
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error obteniendo cantidad m√≠nima para {symbol}: {e}")
            return 0.001  # Default seguro
    
    async def _check_notional_minimum(self, symbol, quantity, price):
        """Verificar si la cantidad cumple el m√≠nimo NOTIONAL de $5 USD"""
        try:
            notional_value = quantity * price
            min_notional = 5.0  # $5 USD m√≠nimo para Binance
            
            print(f"üîç Verificaci√≥n NOTIONAL:")
            print(f"   Cantidad: {quantity:.8f}")
            print(f"   Precio: ${price:.4f}")
            print(f"   Valor total: ${notional_value:.2f}")
            print(f"   M√≠nimo requerido: ${min_notional:.2f}")
            
            if notional_value >= min_notional:
                print(f"   ‚úÖ NOTIONAL OK: ${notional_value:.2f} >= ${min_notional:.2f}")
                return True, notional_value
            else:
                print(f"   ‚ùå NOTIONAL INSUFICIENTE: ${notional_value:.2f} < ${min_notional:.2f}")
                return False, notional_value
                
        except Exception as e:
            print(f"‚ö†Ô∏è Error verificando NOTIONAL: {e}")
            return False, 0.0

    async def recover_open_positions(self):
        """Recuperar posiciones abiertas de la base de datos al iniciar"""
        
        if not self.trade_db:
            print("‚ö†Ô∏è Base de datos no disponible para recuperar posiciones")
            return
            
        try:
            # Obtener trades abiertos de la base de datos
            open_trades = self.trade_db.get_open_trades()
            
            if not open_trades:
                # Si no hay trades en DB pero estamos en modo real, verificar balance real
                if not self.simulation_mode:
                    await self._recover_positions_from_balance()
                else:
                    print("‚úÖ No hay posiciones abiertas para recuperar")
                return
            
            recovered_count = 0
            
            for trade in open_trades:
                symbol = trade['symbol']
                
                # Verificar que la posici√≥n realmente existe en Binance (solo en modo real)
                if not self.simulation_mode:
                    try:
                        balance = self.exchange.fetch_balance()
                        base_currency = symbol.split('/')[0]
                        actual_balance = balance[base_currency]['free']
                        
                        if actual_balance <= 0:
                            # Posici√≥n no existe en Binance, marcar como completada
                            print(f"‚ö†Ô∏è Posici√≥n {symbol} no existe en Binance, cerrando en DB")
                            self.trade_db.update_trade(trade['id'], {
                                'status': 'completed',
                                'exit_timestamp': datetime.now().isoformat(),
                                'pnl': 0,
                                'pnl_percent': 0,
                                'close_reason': 'position_not_found_on_restart'
                            })
                            continue
                        
                        # Verificar si la cantidad es menor al m√≠nimo
                        min_quantity = self._get_minimum_quantity(symbol, actual_balance)
                        if actual_balance < min_quantity:
                            print(f"‚ö†Ô∏è Posici√≥n {symbol} cantidad {actual_balance:.8f} < m√≠nimo {min_quantity:.8f}, cerrando en DB")
                            self.trade_db.update_trade(trade['id'], {
                                'status': 'completed',
                                'exit_timestamp': datetime.now().isoformat(),
                                'pnl': 0,
                                'pnl_percent': 0,
                                'close_reason': 'quantity_below_minimum'
                            })
                            continue
                        
                        # Usar balance real de Binance
                        trade['amount'] = actual_balance
                        
                    except Exception as balance_error:
                        print(f"‚ö†Ô∏è Error verificando balance para {symbol}: {balance_error}")
                        # Continuar con datos de la DB
                
                # Calcular trade_amount si no est√° disponible
                trade_amount = trade.get('trade_amount')
                if not trade_amount:
                    trade_amount = trade['amount'] * trade['entry_price']
                
                # Calcular stop-loss y take-profit si no est√°n definidos
                entry_price = trade['entry_price']
                take_profit_price = trade.get('take_profit_price')
                stop_loss_price = trade.get('stop_loss_price')
                
                if not take_profit_price:
                    take_profit_price = entry_price * 1.025  # 2.5% take profit por defecto
                
                if not stop_loss_price:
                    stop_loss_price = entry_price * 0.99   # 1% stop loss por defecto
                
                # Reconstruir posici√≥n en memoria
                self.positions[symbol] = {
                    'trade_id': trade['id'],
                    'quantity': trade['amount'],
                    'entry_price': entry_price,
                    'entry_time': datetime.fromisoformat(trade['timestamp']) if trade['timestamp'] else datetime.now(),
                    'take_profit_price': take_profit_price,
                    'stop_loss_price': stop_loss_price,
                    'ml_confidence': trade.get('ml_confidence', 0.5),
                    'trade_amount': trade_amount,
                    'fees': trade.get('fees', 0)
                }
                
                recovered_count += 1
                
            if recovered_count > 0:
                print(f"\nüîÑ POSICIONES RECUPERADAS: {recovered_count}")
                for symbol in self.positions:
                    pos = self.positions[symbol]
                    duration = (datetime.now() - pos['entry_time']).total_seconds() / 3600
                    print(f"   üìä {symbol}: {pos['quantity']:.6f} @ ${pos['entry_price']:.4f} ({duration:.1f}h)")
                print()
            
        except Exception as e:
            print(f"‚ùå Error recuperando posiciones: {e}")

    async def _recover_positions_from_balance(self):
        """Recuperar posiciones bas√°ndose en el balance real de Binance cuando no hay trades en DB"""
        
        print("üîç VERIFICANDO POSICIONES REALES EN BINANCE...")
        
        try:
            # Obtener balance completo de Binance
            balance = self.exchange.fetch_balance()
            recovered_positions = {}
            total_value_usd = 0
            
            # Debug: mostrar estructura del balance
            print(f"üîç Estructura del balance: {type(balance)}")
            
            # Lista de monedas a verificar (excluyendo USDT)
            currencies_to_check = []
            
            # El balance de CCXT tiene claves especiales como 'info', 'timestamp', etc.
            # Solo procesamos las monedas reales
            for currency, info in balance.items():
                # Saltar claves especiales de CCXT
                if currency in ['info', 'timestamp', 'datetime', 'free', 'used', 'total']:
                    continue
                    
                if currency == 'USDT':
                    continue
                
                # Verificar que info sea un diccionario
                if not isinstance(info, dict):
                    print(f"‚ö†Ô∏è {currency}: info no es diccionario, es {type(info)}")
                    continue
                    
                free_balance = info.get('free', 0)
                if free_balance > 0:
                    currencies_to_check.append(currency)
            
            if not currencies_to_check:
                print("‚úÖ No se encontraron posiciones en Binance")
                return
            
            print(f"üîç Encontradas {len(currencies_to_check)} monedas con balance: {', '.join(currencies_to_check)}")
            
            # Track positions by category
            significant = []
            tiny = 0
            invalid = []
            
            # Verificar cada moneda
            for currency in currencies_to_check:
                symbol = f"{currency}/USDT"
                free_balance = balance[currency]['free']
                
                try:
                    # Obtener precio actual
                    ticker = self.exchange.fetch_ticker(symbol)
                    current_price = ticker['last']
                    position_value_usd = free_balance * current_price
                    
                    # Solo considerar posiciones significativas (> $5 USD)
                    if position_value_usd < 5.0:
                        tiny += 1
                        continue
                    
                    # Verificar cantidad m√≠nima para trading
                    min_quantity = self._get_minimum_quantity(symbol, free_balance)
                    if free_balance < min_quantity:
                        tiny += 1
                        continue
                    
                    # Track significant position
                    significant.append((symbol, position_value_usd, free_balance, current_price))
                    
                    # Crear posici√≥n recuperada
                    trade_id = f"RECOVERED_{currency}_{int(datetime.now().timestamp())}"
                    
                    # Estimar precios de entrada (usar precio actual como aproximaci√≥n)
                    entry_price = current_price  # Aproximaci√≥n
                    take_profit_price = current_price * 1.025  # 2.5% profit
                    stop_loss_price = current_price * 0.98     # 2% loss
                    
                    recovered_positions[symbol] = {
                        'trade_id': trade_id,
                        'quantity': free_balance,
                        'entry_price': entry_price,
                        'entry_time': datetime.now(),
                        'take_profit_price': take_profit_price,
                        'stop_loss_price': stop_loss_price,
                        'ml_confidence': 0.5,  # Neutral confidence for recovered positions
                        'trade_amount': position_value_usd,
                        'fees': 0,
                        'recovered': True  # Marcar como recuperada
                    }
                    
                    total_value_usd += position_value_usd
                    
                    # Opcional: Crear registro en DB para tracking
                    if self.trade_db:
                        trade_data = {
                            'id': trade_id,
                            'timestamp': datetime.now().isoformat(),
                            'symbol': symbol,
                            'side': 'buy',
                            'amount': free_balance,
                            'entry_price': entry_price,
                            'order_id': f'RECOVERED_{currency}',
                            'status': 'open',
                            'filled_amount': free_balance,
                            'avg_fill_price': entry_price,
                            'fees': 0,
                            'ml_confidence': 0.5,
                            'ml_predicted_success': 0,
                            'ml_model_version': 'recovered_position',
                            'final_score': 0.5,
                            'confidence_threshold': 0.5,
                            'position_size_percent': 0,
                            'stop_loss_price': stop_loss_price,
                            'take_profit_price': take_profit_price,
                            'metadata': json.dumps({
                                'recovered_from_balance': True,
                                'recovery_timestamp': datetime.now().isoformat()
                            }),
                            'created_at': datetime.now().isoformat()
                        }
                        
                        try:
                            self.trade_db.store_trade(trade_data)
                            print(f"   üíæ Posici√≥n {symbol} registrada en DB")
                            
                            # Incrementar contador de analytics
                            if self.analytics_engine:
                                self.analytics_counter += 1
                        except Exception as db_error:
                            print(f"   ‚ö†Ô∏è Error guardando {symbol} en DB: {db_error}")
                    
                except Exception as symbol_error:
                    invalid.append(symbol)
                    continue
            
            # Print summary
            if significant:
                print("üíº Posiciones relevantes detectadas:")
                for sym, val, qty, price in significant:
                    print(f"   ‚Ä¢ {sym}: {qty:.6f} @ ${price:.4f} = ${val:.2f}")
            
            if tiny > 0:
                print(f"‚ÑπÔ∏è  {tiny} posiciones microsc√≥picas (<$5) ignoradas")
            
            if invalid:
                print(f"‚ÑπÔ∏è  Pares no soportados ignorados: {', '.join(invalid)}")
            
            # Agregar posiciones recuperadas al bot
            if recovered_positions:
                self.positions.update(recovered_positions)
                print(f"\nüéâ POSICIONES RECUPERADAS DESDE BALANCE:")
                print(f"   üìä Total posiciones: {len(recovered_positions)}")
                print(f"   üí∞ Valor total: ~${total_value_usd:.2f} USD")
                
                print(f"\n‚ö†Ô∏è NOTA: Estas posiciones fueron recuperadas del balance real.")
                print(f"   Los precios de entrada son aproximaciones basadas en el precio actual.")
                print(f"   El bot monitorear√° estas posiciones normalmente.")
            else:
                print("‚úÖ No se encontraron posiciones significativas para recuperar")
                
        except Exception as e:
            print(f"‚ùå Error recuperando posiciones desde balance: {e}")

    async def sync_balance_with_binance(self):
        """Sincronizar balance con Binance al inicio de cada ciclo"""
        if self.simulation_mode:
            return
            
        try:
            balance = self.exchange.fetch_balance()
            usdt_balance = balance.get('USDT', {}).get('free', 0)
            
            # Actualizar balance interno
            old_balance = self.balance_usdt
            self.balance_usdt = usdt_balance
            
            # V2: Update portfolio tracker equity
            if RISK_MANAGEMENT_V2_AVAILABLE and self.portfolio_v2:
                try:
                    self.portfolio_v2.initial_equity = usdt_balance
                except Exception as e:
                    print(f"‚ö†Ô∏è  Portfolio tracker update error: {e}")
            
            if abs(old_balance - usdt_balance) > 0.01:  # Solo mostrar si hay cambio significativo
                print(f"üîÑ Balance sincronizado: ${old_balance:.2f} ‚Üí ${usdt_balance:.2f}")
                
        except Exception as e:
            print(f"‚ö†Ô∏è Error sincronizando balance: {e}")
    
    async def handle_small_positions(self):
        """Manejar posiciones que son demasiado peque√±as para vender (< $7 USD) - NOTIONAL OPTIMIZED"""
        if not self.positions:
            return
        
        print(f"\nüîç VERIFICANDO POSICIONES PEQUE√ëAS (NOTIONAL < $7)...")
        small_positions = []
        dust_positions = []
        
        for symbol, position in self.positions.items():
            try:
                # Obtener precio actual
                ticker = self.exchange.fetch_ticker(symbol) if not self.simulation_mode else None
                current_price = ticker['last'] if ticker else position['entry_price']
                
                # Calcular valor actual de la posici√≥n (USDT_value)
                position_value = position['quantity'] * current_price
                
                if position_value < 7.0:  # Menos de $7 USD (nuevo threshold)
                    small_positions.append({
                        'symbol': symbol,
                        'position': position,
                        'current_price': current_price,
                        'value': position_value
                    })
                    print(f"   üìâ {symbol}: ${position_value:.2f} (< $7.00)")
                    
                    # Clasificar como dust si es muy peque√±o
                    if position_value < 3.0:
                        dust_positions.append({
                            'symbol': symbol,
                            'position': position,
                            'current_price': current_price,
                            'value': position_value
                        })
                
            except Exception as e:
                print(f"‚ö†Ô∏è Error verificando {symbol}: {e}")
        
        if small_positions:
            print(f"\nüí° ENCONTRADAS {len(small_positions)} POSICIONES PEQUE√ëAS")
            
            # Estrategia para posiciones peque√±as
            for pos_info in small_positions:
                symbol = pos_info['symbol']
                value = pos_info['value']
                
                if value < 3.0:
                    # Dust: intentar cerrar todo si la API lo permite
                    print(f"   üóëÔ∏è DUST {symbol}: ${value:.2f} - Intentando cerrar")
                    try:
                        if not self.simulation_mode:
                            # Intentar venta de dust
                            order = self.exchange.create_market_sell_order(symbol, pos_info['position']['quantity'])
                            print(f"   ‚úÖ Dust cerrado: {symbol}")
                        else:
                            print(f"   ‚úÖ Dust cerrado (simulaci√≥n): {symbol}")
                    except Exception as e:
                        print(f"   ‚ö†Ô∏è No se pudo cerrar dust {symbol}: {e}")
                        print(f"   üìù Marcado para consolidar en pr√≥xima compra")
                        # Marcar para consolidaci√≥n futura
                        if not hasattr(self, 'dust_consolidation_queue'):
                            self.dust_consolidation_queue = set()
                        self.dust_consolidation_queue.add(symbol)
                
                elif 3.0 <= value < 7.0:
                    # Top-up a 8-10 USD si es posible
                    target_value = 9.0  # Target: $9 USD
                    needed_usdt = target_value - value
                    
                    if self.balance_usdt >= needed_usdt and needed_usdt <= 5.0:  # Max $5 top-up
                        print(f"   üìà TOP-UP {symbol}: ${value:.2f} -> ${target_value:.2f} (+${needed_usdt:.2f})")
                        # Aqu√≠ se har√≠a el top-up en implementaci√≥n real
                        if not self.simulation_mode:
                            # L√≥gica de top-up real
                            pass
                        else:
                            print(f"   ‚úÖ Top-up simulado: {symbol}")
                    else:
                        print(f"   üîí Manteniendo {symbol}: ${value:.2f} (insuficiente balance para top-up)")
        else:
            print("‚úÖ Todas las posiciones tienen valor > $7 USD")

    async def emergency_close_all_positions(self, reason="Emergency closure"):
        """Cerrar todas las posiciones de emergencia cuando no hay capital suficiente"""
        if not self.positions:
            print("‚ÑπÔ∏è No hay posiciones abiertas para cerrar")
            return
            
        print(f"\nüö® CIERRE DE EMERGENCIA INICIADO")
        print(f"üìù Raz√≥n: {reason}")
        print(f"üìä Posiciones a cerrar: {len(self.positions)}")
        
        # Primero verificar posiciones peque√±as
        await self.handle_small_positions()
        
        positions_to_close = list(self.positions.keys())
        closed_count = 0
        skipped_count = 0
        
        for symbol in positions_to_close:
            try:
                print(f"üîÑ Intentando cerrar posici√≥n: {symbol}")
                position = self.positions[symbol]
                
                # Obtener precio actual para verificar NOTIONAL
                ticker = self.exchange.fetch_ticker(symbol) if not self.simulation_mode else None
                current_price = ticker['last'] if ticker else position['entry_price']
                
                # Verificar si se puede vender
                notional_ok, notional_value = await self._check_notional_minimum(
                    symbol, position['quantity'], current_price
                )
                
                if notional_ok:
                    # Intentar cerrar normalmente
                    success = await self.close_position(
                        symbol, position, current_price, "EMERGENCY_CLOSE", 0, 0
                    )
                    if success:
                        print(f"‚úÖ Posici√≥n cerrada: {symbol}")
                        closed_count += 1
                    else:
                        print(f"‚ùå Error cerrando posici√≥n: {symbol}")
                else:
                    # Posici√≥n muy peque√±a - marcar como "dust"
                    print(f"üí® Posici√≥n {symbol} es 'dust' (${notional_value:.2f} < $5)")
                    print(f"üîí Manteniendo hasta que crezca o se pueda consolidar")
                    skipped_count += 1
                    
                await asyncio.sleep(1)  # Delay entre cierres
                
            except Exception as e:
                print(f"‚ùå Error procesando {symbol}: {e}")
                # Si hay error NOTIONAL, marcar como dust
                if "NOTIONAL" in str(e):
                    print(f"üí® {symbol} marcado como dust por error NOTIONAL")
                    skipped_count += 1
                else:
                    # Forzar eliminaci√≥n solo si no es error NOTIONAL
                    if symbol in self.positions:
                        del self.positions[symbol]
        
        print(f"\nüèÅ CIERRE DE EMERGENCIA COMPLETADO")
        print(f"‚úÖ Posiciones cerradas: {closed_count}")
        print(f"üí® Posiciones dust mantenidas: {skipped_count}")
        print(f"üìä Posiciones restantes: {len(self.positions)}")
        
        # Actualizar balance despu√©s del cierre
        await self.sync_balance_with_binance()

    async def validate_positions_balance(self):
        """Validar posiciones contra balance real de Binance"""
        if self.simulation_mode or not self.positions:
            return
            
        try:
            balance = self.exchange.fetch_balance()
            
            for symbol, position in self.positions.items():
                base_currency = symbol.split('/')[0]
                if base_currency in balance:
                    actual_balance = balance[base_currency]['free']
                    stored_balance = position['quantity']
                    
                    # Si hay discrepancia significativa (>0.1%), corregir
                    if abs(actual_balance - stored_balance) / stored_balance > 0.001:
                        print(f"‚ö†Ô∏è Corrigiendo balance {symbol}: {stored_balance:.6f} ‚Üí {actual_balance:.6f}")
                        position['quantity'] = actual_balance
                        
        except Exception as e:
            print(f"‚ö†Ô∏è Error validando balances: {e}")

    def print_ml_accuracy_update(self):
        """Print real-time ML accuracy metrics"""
        if len(self.ml_predictions) < 5:
            return
        
        # Calculate accuracy metrics
        correct_predictions = 0
        total_predictions = len(self.ml_predictions)
        high_confidence_correct = 0
        high_confidence_total = 0
        
        total_pnl = 0
        
        for pred in self.ml_predictions:
            predicted_success = pred['predicted_success']
            actual_success = pred['actual_success']
            ml_confidence = pred['ml_confidence']
            pnl_percent = pred['pnl_percent']
            
            total_pnl += pnl_percent
            
            # Check if prediction was correct
            if predicted_success == actual_success:
                correct_predictions += 1
                
                # Use high confidence threshold from config
                high_conf_threshold = self.config.get('ml', {}).get('high_confidence_threshold', 0.75)
                if ml_confidence > high_conf_threshold:
                    high_confidence_correct += 1
            
            high_conf_threshold = self.config.get('ml', {}).get('high_confidence_threshold', 0.75)
            if ml_confidence > high_conf_threshold:
                high_confidence_total += 1
        
        accuracy = (correct_predictions / total_predictions) * 100
        high_conf_accuracy = (high_confidence_correct / high_confidence_total * 100) if high_confidence_total > 0 else 0
        avg_pnl = total_pnl / total_predictions
        
        print(f"\nüß† ML PERFORMANCE UPDATE (√∫ltimos {total_predictions} trades):")
        print(f"   üìä Accuracy general: {accuracy:.1f}%")
        if high_confidence_total > 0:
            print(f"   üéØ Accuracy alta confianza: {high_conf_accuracy:.1f}% ({high_confidence_total} trades)")
        print(f"   üí∞ PnL promedio: {avg_pnl:+.2f}%")
    
    def log_performance(self):
        """Log performance summary"""
        print(f"\nüìä RESUMEN DE PERFORMANCE")
        print(f"üí∞ Balance: ${self.balance_usdt:.2f}")
        print(f"üìà PnL diario: {self.daily_pnl:+.2f}%")
        print(f"üîÑ Trades hoy: {self.trades_today}")
        print(f"üìä Posiciones abiertas: {len(self.positions)}")
        
        if self.trade_history:
            recent_trades = self.trade_history[-3:]
            print(f"üïê √öltimos trades:")
            for trade in recent_trades:
                print(f"   {trade['symbol']}: {trade['pnl_percent']:+.2f}% ({trade['reason']})")
    
    async def start(self):
        """Start the optimized trading bot with daily market analysis"""
        
        print("üöÄ INICIANDO BOT OPTIMIZADO CON AN√ÅLISIS DIARIO DE MERCADO")
        print("=" * 70)
        print(f"üìÖ {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S')} UTC")
        print(f"üéÆ Modo: {'SIMULACI√ìN' if self.simulation_mode else 'REAL'}")
        
        # Get initial balance for display
        if not self.simulation_mode:
            try:
                balance = self.exchange.fetch_balance()
                self.initial_balance_usdt = balance.get('USDT', {}).get('free', 0)
            except:
                self.initial_balance_usdt = 0
        else:
            self.initial_balance_usdt = self.balance_usdt
        
        print(f"üí∞ Balance inicial: ${self.initial_balance_usdt:.2f} USDT")
        print(f"üß† ML Tracking: {'‚úÖ ACTIVO (FASE 2)' if self.trade_db else '‚ùå INACTIVO'}")
        print(f"ü§ñ Model Runtime ID: {MODEL_RUNTIME_ID if MODEL_RUNTIME_ID else 'unknown'}")
        conservative_status = 'active' if self.conservative_mode_state.get('active') else 'inactive'
        print(f"üõ° Safe Mode: {'ON' if self.safe_mode else 'OFF'} | Conservative Mode: {conservative_status}")
        print(f"üåÖ An√°lisis Diario: {'‚úÖ HABILITADO' if self.daily_analysis_enabled else '‚ùå DESHABILITADO'}")
        print(f"üìä S√≠mbolos iniciales (antes del filtro diario): {len(self.symbols)}")
        print(f"‚öôÔ∏è Loop interval: {self.analysis_frequency}s")
        effective_threshold = self.compute_effective_threshold(enhanced=ENHANCED_ML_AVAILABLE)
        base_threshold = self.base_min_confidence
        print(f"üéØ Min confianza actual: {effective_threshold:.3f} (clamp {base_threshold:.3f})")
        print("=" * 70)
        
        # CR√çTICO: Recuperar posiciones abiertas ANTES del an√°lisis diario
        print("\nüîÑ RECUPERANDO POSICIONES ABIERTAS...")
        await self.recover_open_positions()
        await self.validate_positions_balance()
        
        # Run daily analysis if needed (ahora considera posiciones existentes)
        if await self.should_run_daily_analysis():
            print("\nüåÖ Ejecutando an√°lisis diario de mercado...")
            await self.run_daily_analysis()
        else:
            print(f"\nüìä Usando s√≠mbolos actuales: {', '.join(self.symbols[:5])}{'...' if len(self.symbols) > 5 else ''}")
            print(f"üïê √öltimo an√°lisis: {self.last_daily_analysis.strftime('%Y-%m-%d %H:%M') if self.last_daily_analysis else 'Nunca'}")
        
        # Test connection
        if not self.simulation_mode:
            try:
                balance = self.exchange.fetch_balance()
                usdt_balance = balance.get('USDT', {}).get('free', 0)
                print(f"üí∞ Balance USDT real: ${usdt_balance:.2f}")
                self.balance_usdt = usdt_balance
            except Exception as e:
                print(f"‚ùå Error: {e}")
                print("‚ö†Ô∏è  Cambiando a modo simulaci√≥n...")
                self.simulation_mode = True
        else:
            print(f"üí∞ Balance simulado: ${self.balance_usdt:.2f} USDT")
        
        print("‚úÖ Bot iniciado exitosamente")
        print("üîÑ Comenzando loop de trading optimizado...")
        
        loop_count = 0
        
        while True:
            try:
                loop_count += 1
                
                # CIRCUIT BREAKER CHECK - OPTIMIZADO POR ANALYTICS ENGINE
                # Verificar si se debe desactivar emergency mode despu√©s de 1 hora
                if self.emergency_mode and self.emergency_start_time:
                    time_since_emergency = (datetime.now() - self.emergency_start_time).total_seconds() / 3600
                    if time_since_emergency >= 1.0:  # 1 hora
                        self.emergency_mode = False
                        self.emergency_start_time = None
                        print(f"‚úÖ Emergency mode desactivado despu√©s de 1 hora de pausa")
                
                # Saltar trading si estamos en emergency mode
                if self.emergency_mode:
                    print(f"‚è∏Ô∏è  Trading pausado (emergency mode activo)")
                    await asyncio.sleep(60)  # Esperar 1 minuto antes del siguiente check
                    continue
                
                # ESCRIBIR DATOS LIVE PARA ANALYTICS ENGINE
                if loop_count % 2 == 0:  # Cada 2 iteraciones (~60-90 segundos)
                    try:
                        from bot_live_feed_writer import write_bot_live_feed
                        write_bot_live_feed(self)
                    except Exception as e:
                        print(f"‚ö†Ô∏è Error escribiendo live feed: {e}")
                
                # SINCRONIZAR BALANCE AL INICIO DE CADA CICLO
                if loop_count % 5 == 0:  # Cada 5 loops (~7.5 minutos)
                    if self.balance_manager:
                        balance_info = await self.balance_manager.smart_balance_check()
                        if not balance_info['can_trade']:
                            print(f"‚ö†Ô∏è Balance insuficiente para trading: ${balance_info['current_balance']:.2f}")
                            print(f"üéØ Acci√≥n recomendada: {balance_info['recommended_action']}")
                            
                            if balance_info['recommended_action'] == 'close_positions':
                                await self.balance_manager.emergency_balance_recovery()
                    else:
                        await self.sync_balance_with_binance()
                
                # Check for daily analysis (every 50 loops = ~75 minutes)
                if loop_count % 50 == 0 and await self.should_run_daily_analysis():
                    print("\nüåÖ Tiempo para an√°lisis diario peri√≥dico...")
                    await self.run_daily_analysis()
                
                # ‚úÖ MEJORA 2: Update market conditions for conditional threshold (every 10 loops ~15 min)
                if loop_count % 10 == 0 and self.conditional_threshold_manager:
                    try:
                        await self.update_market_conditions_for_threshold()
                    except Exception as e:
                        print(f"‚ö†Ô∏è  Error updating market conditions: {e}")
                
                # üîß FIX: Update data timestamps every loop to prevent stale data
                if self.market_enabled:
                    self.last_data_timestamps['market'] = get_utc_now()
                if self.copy_enabled:
                    self.last_data_timestamps['copy_trading'] = get_utc_now()
                if self.sentiment_enabled:
                    self.last_data_timestamps['sentiment'] = get_utc_now()
                
                # Monitor existing positions first (every loop)
                if self.positions:
                    await self.monitor_positions()
                
                # Performance summary every 10 loops
                if loop_count % 10 == 0:
                    self.log_performance()
                
                # ‚úÖ MEJORA 5: Throughput Health Report every 20 loops (~30 min)
                if loop_count % 20 == 0 and self.throughput_health:
                    try:
                        self.throughput_health.print_health_report()
                    except Exception as e:
                        print(f"‚ö†Ô∏è  Error printing throughput health: {e}")
                
                # Continuous ML monitoring (every loop, but calculates every 15 minutes internally)
                self.calculate_continuous_monitoring_metrics()
                
                # ML retraining scheduler (every 30 loops = ~45 minutes check)
                if loop_count % 30 == 0 and self.ml_enabled and self.ml_engine:
                    await self.check_ml_retraining()
                
                # Analytics Engine update (every 100 trades or every 50 loops)
                if self.analytics_engine:
                    self.analytics_counter += 1
                    # Ejecutar cada 100 trades O cada 50 loops (~75 min), lo que ocurra primero
                    if (self.analytics_counter >= self.analytics_interval or loop_count % 50 == 0):
                        asyncio.create_task(self.run_analytics_update())
                        self.analytics_counter = 0
                
                # FASE 2: Cargar ajustes din√°micos del analytics (cada 10 loops ~15 min)
                if loop_count % 10 == 0:
                    self.load_runtime_adjustments()
                
                # Validate positions balance every 20 loops (~30 minutes)
                if loop_count % 20 == 0:
                    await self.validate_positions_balance()
                
                # VERIFICACI√ìN CR√çTICA: Si balance muy bajo, considerar cierre
                min_operating_balance = 20.0  # $20 m√≠nimo para seguir operando
                if not self.simulation_mode and self.balance_usdt < min_operating_balance and self.positions:
                    print(f"‚ö†Ô∏è Balance cr√≠tico: ${self.balance_usdt:.2f} < ${min_operating_balance:.2f}")
                    print(f"ü§î Evaluando cierre de posiciones...")
                    
                    # Solo cerrar si realmente no podemos hacer m√°s trades
                    min_trade_amount = 15.0
                    if self.balance_usdt < min_trade_amount:
                        if self.balance_manager:
                            await self.balance_manager.emergency_balance_recovery()
                        else:
                            await self.emergency_close_all_positions("Balance insuficiente para continuar operando")
                        
                        # Esperar m√°s tiempo despu√©s del cierre de emergencia
                        print("‚è≥ Esperando 5 minutos despu√©s del cierre de emergencia...")
                        await asyncio.sleep(300)
                        continue
                
                # VERIFICAR SI SE DEBE PAUSAR EL TRADING POR ERRORES EXCESIVOS
                if self.error_handler and self.error_handler.should_pause_trading():
                    print("‚ö†Ô∏è Demasiados errores detectados - Pausando trading por 10 minutos")
                    error_summary = self.error_handler.get_error_summary()
                    print(f"üìä Resumen de errores: {error_summary}")
                    await asyncio.sleep(600)  # 10 minutos
                    continue
                
                # Look for new opportunities (reduced frequency and balance-aware)
                # Use configured max concurrent positions
                risk_config = self.config.get('risk_management', {})
                max_positions = risk_config.get('max_concurrent_positions', 3)
                min_balance_for_new_trades = 15.0  # $15 m√≠nimo para nuevos trades (ajustado para balance actual)
                
                # FASE 2: Verificar si trading est√° pausado por analytics
                if self.trading_paused:
                    if loop_count % 10 == 0:  # Log cada 10 loops
                        print(f"‚è∏Ô∏è  Trading pausado por Analytics Engine")
                    await asyncio.sleep(self.analysis_frequency)
                    continue
                
                if (len(self.positions) < max_positions and 
                    True and  # Every loop (was: loop_count % 2 == 0)
                    self.balance_usdt >= min_balance_for_new_trades):  # Sufficient balance
                    
                    # Analyze symbols for opportunities
                    for symbol in self.symbols:
                        # Filter: only analyze if in current universe OR we have an open position
                        has_position = symbol.replace('/', '') in [pos.replace('/', '') for pos in self.positions.keys()]
                        in_universe = symbol in self.symbols
                        
                        if not has_position and not in_universe:
                            continue  # Skip symbols not in universe and without position
                        
                        if not has_position:
                            analysis = await self.analyze_symbol(symbol)
                            
                            if analysis and analysis.get('action') == 'BUY':
                                # Verificar balance una vez m√°s antes del trade
                                await self.sync_balance_with_binance()
                                if self.balance_usdt >= min_balance_for_new_trades:
                                    success = await self.execute_trade(analysis)
                                    if success:
                                        print(f"‚úÖ Trade ejecutado: {symbol}")
                                        break  # One trade per cycle
                                else:
                                    print(f"‚ö†Ô∏è Balance insuficiente para nuevo trade: ${self.balance_usdt:.2f}")
                                    break
                        
                        await asyncio.sleep(1)  # Small delay between analyses
                
                elif self.balance_usdt < min_balance_for_new_trades and len(self.positions) == 0:
                    print(f"‚ö†Ô∏è Balance muy bajo (${self.balance_usdt:.2f}) y sin posiciones - Modo conservaci√≥n")
                    print("üí§ Esperando recuperaci√≥n de balance o intervenci√≥n manual...")
                    await asyncio.sleep(300)  # Esperar 5 minutos en modo conservaci√≥n
                
                # V2: Flush batched orders periodically
                if RISK_MANAGEMENT_V2_AVAILABLE:
                    try:
                        flushed_count = flush_batched_orders()
                        if flushed_count > 0:
                            print(f"üì¶ Flushed {flushed_count} batched orders")
                    except Exception as e:
                        print(f"‚ö†Ô∏è  Batch flush error: {e}")
                
                # Wait - Optimized frequency
                print(f"üí§ Esperando {self.analysis_frequency} segundos... (Loop {loop_count})")
                await asyncio.sleep(self.analysis_frequency)
                
            except KeyboardInterrupt:
                print("\nüõë Parada solicitada por usuario")
                break
            except Exception as e:
                print(f"‚ùå Error en loop: {e}")
                await asyncio.sleep(60)

    # ==========================================
    # FASE 3: EVENT BUS CALLBACKS
    # ==========================================
    
    async def start_event_listeners(self):
        """Iniciar listeners de eventos del analytics"""
        if not self.event_bus or self.event_listeners_started:
            return
        
        try:
            # Suscribirse a eventos del analytics
            await self.event_bus.subscribe('adjustment_needed', self.on_adjustment_needed)
            await self.event_bus.subscribe('pause_trading', self.on_pause_trading)
            await self.event_bus.subscribe('resume_trading', self.on_resume_trading)
            await self.event_bus.subscribe('risk_alert', self.on_risk_alert)
            await self.event_bus.subscribe('opportunity_detected', self.on_opportunity_detected)
            
            self.event_listeners_started = True
            print("‚úÖ Event listeners iniciados")
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Error iniciando listeners: {e}")
    
    async def on_adjustment_needed(self, event):
        """Reaccionar a ajustes necesarios"""
        try:
            payload = event.payload
            print(f"\nüîß AJUSTE REQUERIDO (EventBus):")
            print(f"   Threshold: {payload.get('threshold')}")
            print(f"   Raz√≥n: {payload.get('reason')}")
            
            # Aplicar ajuste inmediatamente
            if 'threshold' in payload:
                self.base_min_confidence = payload['threshold']
                print(f"   ‚úÖ Threshold actualizado a {self.base_min_confidence:.3f}")
            
            if 'position_multiplier' in payload:
                self.position_multiplier = payload['position_multiplier']
                print(f"   ‚úÖ Position multiplier actualizado a {self.position_multiplier:.2f}")
                
        except Exception as e:
            print(f"‚ö†Ô∏è  Error en on_adjustment_needed: {e}")
    
    async def on_pause_trading(self, event):
        """Pausar trading por evento"""
        try:
            payload = event.payload
            print(f"\n‚ö†Ô∏è  PAUSA DE TRADING SOLICITADA (EventBus):")
            print(f"   Raz√≥n: {payload.get('reason')}")
            print(f"   Win rate: {payload.get('win_rate', 0):.1%}")
            
            self.trading_paused = True
            self.emergency_mode = True
            print(f"   ‚úÖ Trading pausado")
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Error en on_pause_trading: {e}")
    
    async def on_resume_trading(self, event):
        """Reanudar trading"""
        try:
            payload = event.payload
            print(f"\n‚úÖ REANUDANDO TRADING (EventBus):")
            print(f"   Raz√≥n: {payload.get('reason')}")
            
            self.trading_paused = False
            self.emergency_mode = False
            
            if 'new_threshold' in payload:
                self.base_min_confidence = payload['new_threshold']
                print(f"   ‚úÖ Nuevo threshold: {self.base_min_confidence:.3f}")
                
        except Exception as e:
            print(f"‚ö†Ô∏è  Error en on_resume_trading: {e}")
    
    async def on_risk_alert(self, event):
        """Alerta de riesgo"""
        try:
            payload = event.payload
            print(f"\n‚ö†Ô∏è  ALERTA DE RIESGO (EventBus):")
            print(f"   Nivel: {payload.get('risk_level')}")
            print(f"   Max drawdown: {payload.get('max_drawdown', 0):.1%}")
            print(f"   Acci√≥n recomendada: {payload.get('recommended_action')}")
            
            # Aplicar acci√≥n recomendada
            action = payload.get('recommended_action')
            if action == 'reduce_positions':
                self.position_multiplier = max(0.5, self.position_multiplier * 0.7)
                print(f"   ‚úÖ Posiciones reducidas a {self.position_multiplier:.2f}x")
            elif action == 'pause_trading':
                self.trading_paused = True
                print(f"   ‚úÖ Trading pausado por alto riesgo")
                
        except Exception as e:
            print(f"‚ö†Ô∏è  Error en on_risk_alert: {e}")
    
    async def on_opportunity_detected(self, event):
        """Oportunidad detectada"""
        try:
            payload = event.payload
            print(f"\nüí° OPORTUNIDAD DETECTADA (EventBus):")
            print(f"   Patr√≥n: {payload.get('pattern_type')}")
            print(f"   Confianza: {payload.get('confidence', 0):.1%}")
            print(f"   S√≠mbolos: {payload.get('symbols', [])}")
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Error en on_opportunity_detected: {e}")
    
    # ==========================================
    # FIN FASE 3: EVENT BUS CALLBACKS
    # ==========================================

    def print_ml_status(self):
        """Imprime tarjeta de estado completa del sistema ML con m√©tricas de performance 24h"""
        utc_now = get_utc_now()
        
        print("\n" + "="*80)
        print("üß† ML SYSTEM STATUS CARD - EXPANDED HEALTHCHECK")
        print("="*80)
        
        # Get model information from GLOBAL_MODEL_INFO (single source of truth)
        model_name = GLOBAL_MODEL_INFO['model_name']
        model_version = GLOBAL_MODEL_INFO['model_version']
        model_hash = GLOBAL_MODEL_INFO['model_hash'][:8] if GLOBAL_MODEL_INFO['model_hash'] != 'unknown' else 'unknown'
        model_loaded_at = GLOBAL_MODEL_INFO['model_loaded_at']
        
        # Calculate data ages
        sentiment_age_min = self._calculate_data_age_minutes('sentiment')
        copy_age_min = self._calculate_data_age_minutes('copy_trading')
        market_age_min = self._calculate_data_age_minutes('market')
        
        # Compute effective thresholds
        enhanced_threshold = self.compute_effective_threshold(enhanced=True)
        basic_threshold = self.compute_effective_threshold(enhanced=False)
        
        # Calculate decision statistics percentages
        total_decisions = self.ml_decision_stats['total_decisions']
        ml_decisions = self.ml_decision_stats['enhanced'] + self.ml_decision_stats['basic'] + self.ml_decision_stats['basic_ml']
        none_decisions = self.ml_decision_stats['none']
        
        ml_percentage = (ml_decisions / total_decisions * 100) if total_decisions > 0 else 0
        none_percentage = (none_decisions / total_decisions * 100) if total_decisions > 0 else 0
        
        # ===== PERFORMANCE METRICS LAST 24H =====
        print(f"\nüìä PERFORMANCE METRICS (Last 24h)")
        print("-" * 50)
        
        # Calculate 24h performance metrics
        confidence_readings = self.performance_metrics_24h.get('confidence_readings', [])
        if confidence_readings:
            confidences = [conf for _, conf in confidence_readings]
            avg_confidence_24h = sum(confidences) / len(confidences)
            low_conf_count = sum(1 for conf in confidences if conf < 0.50)
            low_conf_ratio = (low_conf_count / len(confidences)) * 100
            max_conf = max(confidences)
            min_conf = min(confidences)
            
            print(f"‚îÇ Confidence Avg (24h)    ‚îÇ {avg_confidence_24h:.3f}                    ‚îÇ")
            print(f"‚îÇ Confidence Range        ‚îÇ {min_conf:.3f} - {max_conf:.3f}            ‚îÇ")
            print(f"‚îÇ Low Confidence Ratio    ‚îÇ {low_conf_ratio:.1f}% (<0.50)             ‚îÇ")
            print(f"‚îÇ Total Predictions       ‚îÇ {len(confidences):,}                      ‚îÇ")
            
            # Trend calculation (simple slope)
            if len(confidences) >= 2:
                recent_half = confidences[len(confidences)//2:]
                early_half = confidences[:len(confidences)//2]
                trend = (sum(recent_half)/len(recent_half)) - (sum(early_half)/len(early_half))
                trend_indicator = "üìà" if trend > 0.01 else "üìâ" if trend < -0.01 else "‚û°Ô∏è"
                print(f"‚îÇ Confidence Trend        ‚îÇ {trend_indicator} {trend:+.3f}                ‚îÇ")
            else:
                print(f"‚îÇ Confidence Trend        ‚îÇ ‚û°Ô∏è Insufficient data        ‚îÇ")
        else:
            print(f"‚îÇ No performance data available for last 24h                    ‚îÇ")
        
        # Decision distribution in 24h
        decision_counts_24h = self.performance_metrics_24h.get('decision_counts', {})
        if decision_counts_24h:
            print(f"\nüìà DECISION DISTRIBUTION (24h)")
            print("-" * 50)
            total_24h = sum(decision_counts_24h.values())
            for signal_type, count in sorted(decision_counts_24h.items()):
                percentage = (count / total_24h * 100) if total_24h > 0 else 0
                print(f"‚îÇ {signal_type:<18} ‚îÇ {count:>6} ({percentage:>5.1f}%)        ‚îÇ")
        
        # ===== DATA STALENESS TABLE =====
        print(f"\nüïê DATA STALENESS STATUS")
        print("-" * 70)
        print(f"‚îÇ {'Source':<15} ‚îÇ {'Age (min)':<10} ‚îÇ {'TTL (min)':<10} ‚îÇ {'Status':<15} ‚îÇ")
        print("-" * 70)
        
        # Market data staleness
        market_status = "üü¢ Fresh" if market_age_min <= self.staleness_config['market_data_ttl_minutes'] else "üü° Stale"
        if market_age_min > self.staleness_config['hard_limit_hours'] * 60:
            market_status = "üî¥ Critical"
        print(f"‚îÇ {'Market':<15} ‚îÇ {market_age_min:<10} ‚îÇ {self.staleness_config['market_data_ttl_minutes']:<10} ‚îÇ {market_status:<15} ‚îÇ")
        
        # Sentiment data staleness
        sentiment_status = "üü¢ Fresh" if sentiment_age_min <= self.staleness_config['sentiment_ttl_minutes'] else "üü° Stale"
        if sentiment_age_min > self.staleness_config['hard_limit_hours'] * 60:
            sentiment_status = "üî¥ Critical"
        enabled_status = " (Enabled)" if self.sentiment_enabled else " (Disabled)"
        print(f"‚îÇ {'Sentiment':<15} ‚îÇ {sentiment_age_min:<10} ‚îÇ {self.staleness_config['sentiment_ttl_minutes']:<10} ‚îÇ {sentiment_status + enabled_status:<15} ‚îÇ")
        
        # Copy trading data staleness
        copy_status = "üü¢ Fresh" if copy_age_min <= self.staleness_config['copy_trading_ttl_minutes'] else "üü° Stale"
        if copy_age_min > self.staleness_config['hard_limit_hours'] * 60:
            copy_status = "üî¥ Critical"
        copy_enabled_status = " (Enabled)" if self.copy_enabled else " (Disabled)"
        print(f"‚îÇ {'Copy Trading':<15} ‚îÇ {copy_age_min:<10} ‚îÇ {self.staleness_config['copy_trading_ttl_minutes']:<10} ‚îÇ {copy_status + copy_enabled_status:<15} ‚îÇ")
        print("-" * 70)
        
        # ===== RECENT EVENTS (Last 5 of each type) =====
        print(f"\nüîÑ RECENT EVENTS (Last 5 of each type)")
        print("-" * 80)
        
        # Model Reloads
        reload_events = self.recent_events.get('reloads', [])
        print(f"\nüîÑ Model Reloads ({len(reload_events)}/5):")
        if reload_events:
            for i, event in enumerate(reload_events[-5:], 1):
                timestamp = event['timestamp'].strftime('%H:%M:%S')
                data = event['data']
                status = "‚úÖ" if data.get('success', False) else "‚ùå"
                print(f"  {i}. [{timestamp}] {status} {data.get('reason', 'Unknown')} - Hash: {data.get('new_hash', 'N/A')[:8]}")
        else:
            print(f"  No reload events recorded")
        
        # Fallback Events
        fallback_events = self.recent_events.get('fallbacks', [])
        print(f"\nüîÄ Enhanced‚ÜíBasic Fallbacks ({len(fallback_events)}/5):")
        if fallback_events:
            for i, event in enumerate(fallback_events[-5:], 1):
                timestamp = event['timestamp'].strftime('%H:%M:%S')
                data = event['data']
                reason = data.get('reason', 'Unknown')
                print(f"  {i}. [{timestamp}] Fallback triggered - Reason: {reason}")
        else:
            print(f"  No fallback events recorded")
        
        # Conservative Mode Events
        conservative_events = self.recent_events.get('conservative_mode', [])
        print(f"\nüõ°Ô∏è  Conservative Mode Changes ({len(conservative_events)}/5):")
        if conservative_events:
            for i, event in enumerate(conservative_events[-5:], 1):
                timestamp = event['timestamp'].strftime('%H:%M:%S')
                data = event['data']
                action = "Activated" if data.get('activated', False) else "Deactivated"
                confidence = data.get('confidence', 0)
                print(f"  {i}. [{timestamp}] {action} - ML Confidence: {confidence:.3f}")
        else:
            print(f"  No conservative mode changes recorded")
        
        # Staleness Penalty Events
        staleness_events = self.recent_events.get('staleness_penalties', [])
        print(f"\n‚è∞ Staleness Penalties ({len(staleness_events)}/5):")
        if staleness_events:
            for i, event in enumerate(staleness_events[-5:], 1):
                timestamp = event['timestamp'].strftime('%H:%M:%S')
                data = event['data']
                sources = ', '.join(data.get('sources', []))
                impact = data.get('confidence_impact', 'N/A')
                print(f"  {i}. [{timestamp}] Sources: {sources} - Impact: {impact}")
        else:
            print(f"  No staleness penalties recorded")
        
        # ML Errors
        error_events = self.recent_events.get('errors', [])
        print(f"\n‚ùå ML Errors ({len(error_events)}/5):")
        if error_events:
            for i, event in enumerate(error_events[-5:], 1):
                timestamp = event['timestamp'].strftime('%H:%M:%S')
                data = event['data']
                error_type = data.get('type', 'Unknown')
                message = data.get('message', 'No details')[:50]
                print(f"  {i}. [{timestamp}] {error_type}: {message}...")
        else:
            print(f"  No ML errors recorded")
        
        # ===== STRUCTURED LOGGING FOR PIPELINE =====
        print(f"\nüîç STRUCTURED STATUS (for pipeline integration):")
        print(f"ML_STATUS_CARD: timestamp={utc_now.isoformat()}")
        print(f"ML_STATUS_CARD: ml_loaded={ML_PREDICTOR_AVAILABLE}, enhanced_ml={ENHANCED_ML_AVAILABLE}")
        print(f"ML_STATUS_CARD: model_name={model_name}, model_version={model_version}, model_hash={model_hash}, model_loaded_at={model_loaded_at}")
        print(f"ML_STATUS_CARD: enhanced_threshold={enhanced_threshold:.3f}, basic_threshold={basic_threshold:.3f}")
        print(f"ML_STATUS_CARD: sentiment_age_min={sentiment_age_min}, copy_age_min={copy_age_min}, market_age_min={market_age_min}")
        print(f"ML_STATUS_CARD: ml_decisions_pct={ml_percentage:.1f}, none_decisions_pct={none_percentage:.1f}, total_decisions={total_decisions}")
        print(f"ML_STATUS_CARD: sentiment_enabled={self.sentiment_enabled}, copy_enabled={self.copy_enabled}, market_enabled={self.market_enabled}")
        print(f"ML_STATUS_CARD: simulation_mode={self.simulation_mode}, safe_mode={self.safe_mode}")
        
        if confidence_readings:
            print(f"ML_STATUS_CARD: avg_confidence_24h={avg_confidence_24h:.3f}, low_conf_ratio_24h={low_conf_ratio:.1f}")
        
        # Conservative mode status
        conservative_active = self.conservative_mode_state.get('active', False)
        print(f"ML_STATUS_CARD: conservative_mode_active={conservative_active}")
        if conservative_active:
            activation_time = self.conservative_mode_state.get('activation_time')
            if activation_time:
                duration = utc_now - activation_time
                print(f"ML_STATUS_CARD: conservative_mode_duration_min={duration.total_seconds()/60:.1f}")
        
        # ===== HUMAN-READABLE SUMMARY =====
        print(f"\nüì¶ MODEL STATUS:")
        print(f"   modelo: {model_name}")
        print(f"   hash: {model_hash}")
        print(f"   loaded_at: {model_loaded_at}")
        print(f"   ml_loaded: {ML_PREDICTOR_AVAILABLE}")
        print(f"   enhanced_ml: {ENHANCED_ML_AVAILABLE}")
        
        print(f"\n‚öôÔ∏è  THRESHOLDS:")
        print(f"   enhanced_threshold: {enhanced_threshold:.3f}")
        print(f"   basic_threshold: {basic_threshold:.3f}")
        print(f"   safe_mode: {self.safe_mode}")
        
        # Conservative mode status
        if conservative_active:
            print(f"   üõ°Ô∏è  CONSERVATIVE MODE: ACTIVE")
            activation_time = self.conservative_mode_state.get('activation_time')
            if activation_time:
                duration = utc_now - activation_time
                print(f"   ‚îî‚îÄ Active for: {duration}")
                print(f"   ‚îî‚îÄ Threshold boost: +{self.conservative_mode_state['threshold_boost']:.3f}")
                print(f"   ‚îî‚îÄ Position reduction: -{self.conservative_mode_state['position_reduction']:.1%}")
        else:
            print(f"   üõ°Ô∏è  Conservative mode: Inactive")
        
        print(f"\nüìà DECISION STATISTICS:")
        print(f"   Total decisions: {total_decisions}")
        if total_decisions > 0:
            print(f"   ML decisions: {ml_decisions} ({ml_percentage:.1f}%)")
            print(f"     - Enhanced ML: {self.ml_decision_stats['enhanced']} ({self.ml_decision_stats['enhanced']/total_decisions*100:.1f}%)")
            print(f"     - Basic ML: {self.ml_decision_stats['basic']} ({self.ml_decision_stats['basic']/total_decisions*100:.1f}%)")
            print(f"     - Basic ML (fallback): {self.ml_decision_stats['basic_ml']} ({self.ml_decision_stats['basic_ml']/total_decisions*100:.1f}%)")
            print(f"   None decisions: {none_decisions} ({none_percentage:.1f}%)")
            print(f"   Other decisions: {self.ml_decision_stats['market_analysis'] + self.ml_decision_stats['base_score']} ({(self.ml_decision_stats['market_analysis'] + self.ml_decision_stats['base_score'])/total_decisions*100:.1f}%)")
        else:
            print(f"   No decisions recorded yet")
        
        # Session info
        session_duration = utc_now - self.ml_decision_stats['last_reset']
        print(f"   Session duration: {session_duration}")
        
        # Current Hour & Penalties
        current_hour = utc_now.hour
        print(f"\n‚è∞ CURRENT STATUS (TRADING 24/7 ACTIVO):")
        print(f"   current_hour: {current_hour} UTC")
        print(f"   mercado_global: {'Asia-Pac' if 0 <= current_hour < 8 else 'Europa' if 8 <= current_hour < 16 else 'Am√©rica' if 16 <= current_hour < 22 else 'Am-Tarde'}")
        print(f"   daily_analysis_enabled: {self.daily_analysis_enabled}")
        
        # Bypass Detection
        print(f"\nüîç BYPASS CONDITIONS:")
        bypass_conditions = []
        if not ML_PREDICTOR_AVAILABLE and not ENHANCED_ML_AVAILABLE:
            bypass_conditions.append("no_ml_available")
        # Check if effective threshold is too high (using enhanced ML as reference)
        max_safe_threshold = self.config.get('ml', {}).get('max_safe_threshold', 0.8)
        if enhanced_threshold > max_safe_threshold:
            bypass_conditions.append("high_threshold_risk")
        
        if bypass_conditions:
            print(f"   ‚ö†Ô∏è  Active conditions: {', '.join(bypass_conditions)}")
        else:
            print(f"   ‚úÖ No bypass conditions detected")
        
        # Shadow Mode Status (FASE 2)
        if self.shadow_mode:
            print(f"\nüî¨ SHADOW MODE (FASE 2 MODEL):")
            try:
                report = self.shadow_mode.get_comparison_report()
                print(f"   Status: {'üü¢ Active' if SHADOW_MODE_AVAILABLE else 'üî¥ Inactive'}")
                print(f"   Total Predictions: {report['total_predictions']}")
                print(f"   Agreement Rate: {report['agreement_rate']:.1%}")
                print(f"   FASE 2 Precision: {report['fase2_precision']:.3f}")
                print(f"   Production Precision: {report['production_precision']:.3f}")
                if report['total_predictions'] > 0:
                    print(f"   Avg Confidence Diff: {report['avg_confidence_diff']:+.3f}")
                    print(f"   üìä Ready for evaluation with {report['total_predictions']} samples")
            except Exception as e:
                print(f"   ‚ö†Ô∏è  Error getting Shadow Mode report: {e}")
        else:
            print(f"\nüî¨ SHADOW MODE: Not available")
        
        print(f"\n" + "="*80)
        print("‚úÖ ML Status check complete - exiting without starting trading")
        print("="*80)


async def main():
    """Main function with CLI argument parsing"""
    
    # Parse CLI arguments
    parser = argparse.ArgumentParser(description='Trading Bot with ML Healthcheck')
    parser.add_argument('--ml-status', action='store_true', help='Show ML system status and exit')
    args = parser.parse_args()
    
    # Check environment variable or CLI flag
    if os.getenv('ML_STATUS') == '1' or args.ml_status:
        print("üîç ML HEALTHCHECK REQUESTED")
        trader = AutoStartBinanceTrader()
        trader.print_ml_status()
        return
    
    # Normal bot execution
    try:
        trader = AutoStartBinanceTrader()
        await trader.start()
        
    except KeyboardInterrupt:
        print("\nüõë Bot detenido por usuario")
    except Exception as e:
        print(f"‚ùå Error cr√≠tico: {e}")
    finally:
        print("üëã Bot finalizado")


def print_ml_status():
    """Imprime tarjeta de estado completa del sistema ML"""
    print("\n" + "="*60)
    print("üß† ML SYSTEM HEALTHCHECK")
    print("="*60)
    
    # Model Status
    print(f"\nüì¶ MODEL STATUS:")
    try:
        if ML_PREDICTOR_AVAILABLE:
            from simple_ml_predictor import ml_predictor
            model_info = ml_predictor.get_model_info()
            print(f"   ml_loaded: {model_info.get('ml_loaded', False)}")
            print(f"   model_name: {model_info.get('model_name', 'unknown')}")
            print(f"   model_path: {model_info.get('model_path', 'unknown')}")
            print(f"   model_hash: {model_info.get('model_hash', 'unknown')}")
            print(f"   framework: {model_info.get('framework', 'unknown')}")
            print(f"   params_count: {model_info.get('params_count', 'unknown')}")
            print(f"   features_count: {model_info.get('features_count', 'unknown')}")
            print(f"   accuracy: {model_info.get('accuracy', 0):.3f}")
            print(f"   version: {model_info.get('version', 'unknown')}")
        else:
            print(f"   ml_loaded: False")
            print(f"   reason: ML_PREDICTOR_AVAILABLE=False")
    except Exception as e:
        print(f"   ml_loaded: False")
        print(f"   error: {e}")
    
    # Enhanced ML Status
    print(f"\nüöÄ ENHANCED ML STATUS:")
    print(f"   enhanced_ml_available: {ENHANCED_ML_AVAILABLE}")
    if ENHANCED_ML_AVAILABLE:
        print(f"   mode: offline")
        print(f"   copytrading_enabled: True")
        print(f"   copytrading_source: offline_enhanced_ml")
        print(f"   sentiment_enabled: True")
        print(f"   sentiment_source: offline_time_based")
    
    # Training Pipeline
    print(f"\nüéØ TRAINING PIPELINE:")
    try:
        import os
        if os.path.exists('ml_trainer_market_analysis.py'):
            print(f"   training_pipeline: present")
            print(f"   trainer_file: ml_trainer_market_analysis.py")
            print(f"   split_strategy: TimeSeriesSplit")
            print(f"   determinism: on")
        else:
            print(f"   training_pipeline: absent")
    except:
        print(f"   training_pipeline: unknown")
    
    # Runtime Configuration
    bot = AutoStartBinanceTrader()
    print(f"\n‚öôÔ∏è  RUNTIME CONFIG:")
    print(f"   simulation_mode: {bot.simulation_mode}")
    print(f"   testnet: {bot.testnet}")
    effective_threshold = bot.compute_effective_threshold(enhanced=ENHANCED_ML_AVAILABLE)
    print(f"   effective_threshold: {effective_threshold:.3f}")
    print(f"   safe_mode: {os.path.exists('config/safe_mode_config.json')}")
    
    # Data Sources
    print(f"\nüìä DATA SOURCES:")
    print(f"   market_source: binance_ccxt")
    print(f"   sentiment_enabled: {bot.use_sentiment_analysis}")
    print(f"   fundamental_enabled: {bot.use_fundamental_analysis}")
    print(f"   advanced_technical: {bot.use_advanced_technical}")
    
    # Current Hour & Global Markets (24/7 Trading)
    current_hour = datetime.now().hour
    print(f"\n‚è∞ TRADING 24/7 STATUS:")
    print(f"   current_hour: {current_hour}")
    print(f"   mercado_activo: {'Asia-Pac√≠fico' if 0 <= current_hour < 8 else 'Europa' if 8 <= current_hour < 16 else 'Am√©rica' if 16 <= current_hour < 22 else 'Am√©rica Tarde'}")
    print(f"   boost_aplicado: {'1.08x (Asia)' if 0 <= current_hour < 8 else '1.05x (Europa)' if 8 <= current_hour < 16 else '1.06x (Am√©rica)' if 16 <= current_hour < 22 else '1.03x (Am-Tarde)'}")
    
    print(f"\n" + "="*60)


def main_cli():
    """Main entry point with CLI argument parsing"""
    import argparse
    import os
    
    parser = argparse.ArgumentParser(description='Trading Bot with ML')
    parser.add_argument('--ml-status', action='store_true', help='Show ML system status and exit')
    args = parser.parse_args()
    
    # Check environment variable or CLI flag
    if os.getenv('ML_STATUS') == '1' or args.ml_status:
        print("üîç ML HEALTHCHECK REQUESTED")
        trader = AutoStartBinanceTrader()
        trader.print_ml_status()
        return
    
    # Normal bot execution
    asyncio.run(main())


if __name__ == "__main__":
    main_cli()
class ContinuousMonitor:
    def __init__(self):
        self.confidence_history = []
        self.last_calculation = datetime.utcnow()
        
    def add_confidence(self, confidence):
        """Agrega nueva confidence al historial"""
        now = datetime.utcnow()
        self.confidence_history.append((now, confidence))
        
        # Mantener solo √∫ltimas 24 horas
        cutoff = now - timedelta(hours=24)
        self.confidence_history = [(t, c) for t, c in self.confidence_history if t > cutoff]
        
    def calculate_metrics(self):
        """Calcula m√©tricas de monitoreo"""
        now = datetime.utcnow()
        
        # Calcular cada 15 minutos
        if (now - self.last_calculation).total_seconds() < 900:
            return
            
        self.last_calculation = now
        
        if not self.confidence_history:
            return
            
        # Confidence promedio √∫ltima hora
        one_hour_ago = now - timedelta(hours=1)
        recent_confidences = [c for t, c in self.confidence_history if t > one_hour_ago]
        
        if recent_confidences:
            avg_conf_1h = sum(recent_confidences) / len(recent_confidences)
            low_conf_ratio = sum(1 for c in recent_confidences if c < 0.50) / len(recent_confidences)
            
            print(f"üìä ml_conf_avg_1h={avg_conf_1h:.3f} low_conf_ratio_1h={low_conf_ratio:.3f}")
            
            # Trigger recovery si ratio alto
            if low_conf_ratio > 0.35:
                print("‚ö†Ô∏è recovery_trigger=true reason=high_low_conf_ratio")
                self.trigger_recovery()
                
    def trigger_recovery(self):
        """Dispara proceso de recovery"""
        print("üîÑ Iniciando proceso de recovery autom√°tico")
        # Aqu√≠ ir√≠a la l√≥gica de recovery

# Instancia global
continuous_monitor = ContinuousMonitor()

def get_ml_prediction_with_fallback(data, config):
    """Obtiene predicci√≥n ML con fallback autom√°tico"""
    
    try:
        # Intentar enhanced ML primero
        prediction = get_enhanced_ml_prediction(data)
        if prediction is not None:
            log_ml_decision(signal_used="enhanced_ml", 
                          final_confidence=prediction,
                          effective_threshold=compute_effective_threshold(config))
            return prediction
            
    except Exception as e:
        print(f"‚ö†Ô∏è Enhanced ML fall√≥: {e}")
        
    try:
        # Fallback a basic ML
        prediction = get_basic_ml_prediction(data)
        if prediction is not None:
            log_ml_decision(signal_used="basic_ml", 
                          final_confidence=prediction,
                          effective_threshold=compute_effective_threshold(config),
                          reason_for_bypass=BypassReason.ML_UNAVAILABLE)
            return prediction
            
    except Exception as e:
        print(f"‚ùå Basic ML tambi√©n fall√≥: {e}")
        
    # Si todo falla, usar threshold m√≠nimo pero no apagar ML
    log_ml_decision(signal_used="none", 
                  final_confidence=0.0,
                  effective_threshold=compute_effective_threshold(config),
                  reason_for_bypass=BypassReason.ML_UNAVAILABLE)
    return 0.0
